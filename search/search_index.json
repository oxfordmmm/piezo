{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#piezo","title":"piezo","text":"<p>Predict the effect of a genetic mutation on the effect of an antibiotic using a supplied AMR catalogue.</p> <p>This code was developed as part of the CRyPTIC international tuberculosis consortium. If you would like to use the software commercially, please consult the LICENCE file.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#using-pip","title":"Using <code>pip</code>","text":"<p>This will install the most recent release on PyPI.</p> <pre><code>pip install piezo\n</code></pre>"},{"location":"#from-github","title":"From GitHub","text":"<p>This will install the current version from GitHub and therefore may be ahead of the PyPI version.</p> <pre><code>git clone https://github.com/oxfordmmm/piezo\ncd piezo\npip install .\n</code></pre> <p>The pre-requisites are all fairly standard and are listed in <code>setup.cfg</code> so will be automatically installed.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>API documentation for developers can be found here: https://oxfordmmm.github.io/piezo/</p>"},{"location":"#included-files","title":"Included files","text":"<pre><code>$ ls tests/test-catalogue/\nNC_004148.2.gbk                    NC_004148.2_TEST_GM1_RFUS_v1.0.csv\n</code></pre> <p>NC_004148 is the reference genome of the human metapneumovirus and is used primarily for unit testing since it is small and fast to parse.</p>"},{"location":"#design-of-amr-catalogue","title":"Design of AMR catalogue","text":"<p><code>piezo</code> is written so as to be extendable in the future to other ways of describing genetic variation with respect to a reference. It includes the concept of a <code>grammar</code> which specifies how the genetic variation is described.</p> <p>At present only a single grammar, <code>GARC1</code> is supported. <code>GARC</code> is short for Grammar for Antimicrobial Resistance Catalogues. This grammar is described in more detail elsewhere, however in brief, it is a gene-centric view (and therefore has no way of describing genetic variation that lies outside a coding region, other than as a 'promoter' mutation). All mutations start with the gene (or locus) name which must match the name of a gene (or locus) in the relevant GenBank file. It is the user's responsibility to ensure this, although e.g. the <code>gumpy</code> package can be used to perform such sanity checks. The mutation is delineated from the gene using a <code>@</code> symbol and within the mutation <code>_</code> is used as a field separator to separate the different components. All variation is described as either a <code>SNP</code> or an <code>INDEL</code>. If they occur within a coding region <code>SNP</code>s are specified by their effect on the amino acids which are always in UPPERCASE e.g. <code>rpoB@S450L</code>. If in the assumed promoter region, then the nucleotide change and position is specified e.g. <code>fabG1@c-15t</code>. Nucleotides are always in lowercase. <code>INDEL</code>s can be specified at different levels of granularity e.g. <code>rpoB@1250_indel</code> means 'any insertion of deletion at this position', but we could equally be highly specific and say <code>rpoB@1250_ins_cta</code> which means 'an insertion of cta at this position'. There is also the special case of frameshifting mutations which are described by <code>fs</code>.</p> <p>Wildcards are also supported. Hence <code>rpoB@*?</code> means 'any non-synoymous mutation in the coding region of the protein'. To avoid confusion the stop codon is represented by <code>!</code> which is non-standard. Het calls are, at present, represented by a <code>Z</code> or <code>z</code> depending on whether they occur in the coding or promoter regions. This may be extended in the future. Likewise null calls are represented by an <code>X</code> or <code>x</code>.</p> <p>The general principle is each mutation can 'hit' multiple rules in the catalogue, but it is the most specific rule that will be followed. Hence consider a toy example, again from TB</p> <pre><code>rpoB@*?     RIF   U   any non-synoymous mutation in the coding region has an unknown effect of RIF\nrpoB@S450?  RIF   R   any non-synoymous mutation at Ser450 confers resistance\nrpoB@S450Z  RIF   F   a het call at Ser450 should be reported as an F (fail).\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>A demonstration script called <code>piezo-predict.py</code> can be found in the <code>bin/</code> folder of the repository which following installation should be in your <code>$PATH</code>. A made-up catalogue for testing purposes can be found in <code>tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv</code> which is based on the Human metapneumovirus, however the entries are fictious. It contains two drugs and a series of mutations in the M2 gene.</p> <pre><code>$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@L73L\n{'DRUG_B': 'S', 'DRUG_A': 'S'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@L73R\n{'DRUG_A': 'R', 'DRUG_B': 'U'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@L73Z\n{'DRUG_B': 'S', 'DRUG_A': 'F'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_indel\n{'DRUG_B': 'U', 'DRUG_A': 'U'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_ins\n{'DRUG_B': 'U', 'DRUG_A': 'U'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_ins_2\n{'DRUG_B': 'U', 'DRUG_A': 'U'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_ins_3\n{'DRUG_A': 'U', 'DRUG_B': 'R'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_ins_4\n{'DRUG_B': 'U', 'DRUG_A': 'U'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_ins_cta\n{'DRUG_B': 'R', 'DRUG_A': 'U'}\n</code></pre>"},{"location":"nomenclature/","title":"A General Ontology for Antimicrobial Resistance Catalogues (GOARC)","text":""},{"location":"nomenclature/#assumptions","title":"Assumptions","text":"<ul> <li>Resistance to an antimicrobial can be predicted by genetics i.e. the presence or absence of specific genetic sequences. AMR catalogues therefore need to specify</li> <li>the presence of absence of genes (i.e. coding sequences)</li> <li>changes, insertions or deletions to coding sequences and also to promoter regions</li> <li>Any code that parses catalogues should</li> <li>apply general rules first and specific rules last to allow specific entries to override general entries.</li> <li>have unit testing using known, high-confidence mutations to provide confidence that the code is working as intended</li> <li>Where possible, catalogues should be complete and computer-readable i.e. no logic should be written in to any computer code and the catalogue should not contain rules written in sentences! For example, catalogues should specify the effect of synonymous mutations in the coding region of genes of interest.</li> <li>This ontology is designed with non-additive qualitative AMR catalogues in mind i.e. if both mutations X and Y confer Resistance, then having both mutations present would also lead to a prediction of R. Using the ontology for quantitative, additive catalogues which predict the change in minimum inhibitor concentration (MIC) with respect to an arbitary reference (e.g. the mode MIC for susceptible strains) would be simple. Since each row is a mutation, describing non-linearities is more challenging. This could be achieved by allowing an entry in the catalogue to be a list of mutations (or gene presences) which, being more specific, would then override any more general rules.</li> </ul>"},{"location":"nomenclature/#nomenclature","title":"Nomenclature","text":""},{"location":"nomenclature/#genes","title":"Genes","text":"<p>For core chromosomal genes, the name of the gene in the catalogue must match either the gene name or locus tag in the GenBank reference. E.g. rpoB in M. tuberculosis can also be referred to as Rv0667.</p> <pre><code>gene            759807..763325\n                     /gene=\"rpoB\"\n                     /locus_tag=\"Rv0667\"\n</code></pre> <p>For genes that are not present in the reference genome for a species, for example plasmid or other mobile genetic elements, ensuring consistency of nomenclature is more difficult. The developer must ensure that the name given to specific genetic elements by the bioinformatics workflow matches the name found in the catalogue, otherwise there will be false negatives leading to very major errors.</p>"},{"location":"nomenclature/#amino-acids-and-nucleotides","title":"Amino acids and nucleotides","text":"<ul> <li>Amino acids are always given\u00a0in UPPERCASE. Nucleotides in lowercase. This should be checked by the code and fail if this is not the case ('halt and catch fire').</li> <li>Het calls at present are given by the letter z, hence <code>Z</code> for an amino acid or <code>z</code> for a base.</li> <li>Likewise, null calls are given by the letter x, hence <code>X</code> for an amino acid or <code>x</code> for a base.</li> <li>Hence code should insist that</li> </ul> <pre><code>aminoacids in ['A','C','D','E','F','G','H','I','K','L','M','N','O','P','Q','R','S','T','V','W','X','Y','Z','!']\n\nnucleotides in ['a','c','t','g','x','z']\n</code></pre>"},{"location":"nomenclature/#wildcards-and-other-special-characters","title":"Wildcards and other special characters","text":"<p>This is designed to be general and expandable (especially for indels)</p> <ul> <li><code>*</code> is reserved to mean any residue (or base, depending on context). Note that <code>-*</code> is expanded to mean 'any promoter position'</li> <li><code>!</code> is reserved for the STOP codon. This is defined in the private method <code>_setup_conversion_dicts()</code> in <code>cryptic.genetics.gene</code> (rather than <code>Stop</code> or <code>*</code> as previously)</li> <li><code>?</code> is a wildcard for any non-synonmous mutation and <code>=</code> is a wildcard for the synoymous mutation</li> <li><code>&amp;</code> can be used to join any valid mutation with any other valid mutation to form a multi-mutation - allowing detailing of several mutations in a single row of a catalogue</li> </ul>"},{"location":"nomenclature/#catalogue-entries","title":"Catalogue entries","text":""},{"location":"nomenclature/#presence-or-absence-of-genes","title":"Presence or absence of genes","text":"<p>This is the highest level of the hierarchy and these rules are therefore applied first. A gene presence entry is simply</p> <p><code>oxa48</code></p> <p>To avoid confusion with the wildcards, we use <code>~</code> to indicate logical NOT hence</p> <p><code>~oxa48</code></p> <p>indicates the absence of gene oxa48.</p>"},{"location":"nomenclature/#genetic-mutations","title":"Genetic mutations","text":"<ul> <li>There are two types of mutations: single nucleotide polymorphisms (SNP) or insertions/deletions (INDEL), each of which can apply to a coding region of a protein (CDS) or the coding region of ribosomal RNA (RNA) or a promoter (PROM). A CDS is always translated into an amino acid sequence and hence the numeric position is the number of the amino acid residue, whereas a gene encoding rRNA needs to be treated as nucleotides, so is not translated.</li> <li>In the catalogue these are specified by the TYPE (SNP or INDEL) and AFFECTS (CDS, RNA or PROM). No other values are allowed.</li> </ul>"},{"location":"nomenclature/#single-nucleotide-polymorphisms-snps","title":"Single nucleotide polymorphisms (SNPs)","text":"<p>The general format is</p> <p><code>gene@mutation</code></p> <p>Splitting the mutation on <code>@</code> therefore always gives you 2 strings which is used to identfy this as a SNP. Below are three examples for a CDS, RNA and PROM SNP:</p> <p><code>rpoB@S450L</code>, <code>rrs@a1402t</code> and <code>fabG1@c-15t</code>.</p> <p>Note that position is context dependent! Hence for the CDS mutation it is amino acid number, whilst for the RNA and PROM mutation it is nucleotide number! Since the reference amino acid or base is recorded in all cases, this is always checked against the supplied (H37rV) Genbank file and a warning is logged if it is different - this likely indicates a different reference was used to define the mutation.</p> <p>Any non-synonymous mutation can be encoded as</p> <p><code>rpoB@S450?</code>, <code>rrs@a1402?</code> and <code>fabG1@c-15?</code></p> <p>Any non-synonymous (which is has to be) mutation to the stop codon only makes sense for CDS mutations i.e.</p> <p><code>rpoB@!1172?</code></p> <p>The synonymous mutations are obviously</p> <p><code>rpoB@S450S</code>, <code>rrs@a1402a</code>, <code>fabG1@c-15c</code></p> <p>Allowing <code>*</code> to mean 'any position' then we can start to create more complex rules.</p> <p>For example, any non-synonymous mutation of these genes</p> <p><code>rpoB@*?</code>, <code>rrs@*?</code>, <code>fabG1@*?</code></p> <p>Whilst any non-synonymous mutation in the promoter of these genes is</p> <p><code>rpoB@-*?</code>, <code>rrs@-*?</code>, <code>fabG1@-*?</code></p> <p>Note that the reference amino acid or base cannot, and therefore is not, specified. Likewise, all synonymous mutations in the coding sequences are</p> <p><code>rpoB@*=</code>, <code>fabG1@*=</code></p> <p>Lastly, these rules have to be applied in a descending hierarchy which is based on the assumption that more specfic rules should override more general rules. This is a made up example.</p> <pre><code>rpoB@*= S\nrpoB@*?  U\nrpoB@450? R\nrpoB@S450T S\n</code></pre> <p>The first two rules say that synonymous mutations in the coding region of rpoB have no effect but any non-synonymous mutation has an unknown effect (U). The third second rule overrides this at position 450 so adds \"except at position 450 where any non-synonymous mutation is classified R\", then the final rule adds a final exception \"except if the alt/target amino acid is Threonine, in which case it is classified S.</p> <p>An important implication of this is that the rules can INTERACT and these needs to be born in mind (but this was always true..)</p>"},{"location":"nomenclature/#insertions-or-deletions-of-nucleotides-indels","title":"Insertions or deletions of nucleotides (INDELs)","text":"<p>INDELs require a more complex hierarchy, although only the top level is used for the time being. The top level is</p> <p><code>gene@position_indel</code></p> <p>e.g. <code>rpoB@1300_indel</code></p> <p>which means any insertion or deletion of any length at this position. If position is positive it is the nucleotide number within the coding sequence. If negative, it is within the promoter.</p> <p>This can be overridden with more specific rules, the first of which is</p> <p><code>gene@position_fs</code></p> <p>e.g. <code>rpoB@1300_fs</code></p> <p>which means any frame-shifting mutation at the position. In other words the length of the insertion or deletion is not divisible by three. Then we have a more specific format</p> <p><code>gene@position_type_length</code></p> <p>where the length is specified e.g.</p> <p><code>rpoB@1300_ins_2</code></p> <p>means any insertion of two bases at position 1300 in rpoB. Logically, the numbering is again nucleotide (not amino acid residue). Finally, and not implemented yet, the specific bases inserted can be specific</p> <p><code>rpoB@1300_ins_ca</code></p> <p>Note that the deepest rule for deletions is the layer above i.e. <code>rpoB@1300_del_2</code> since we cannot specific which bases were deleted! Hence we end up with this descending hierarchy</p> <pre><code>rpoB@*_indel                        any insertion or deletion in the CDS of rpoB\nrpoB@*_ins, rpoB_*_del              any insertion (or deletion) in the CDS\nrpoB@*_ins_2, rpoB_*_del_2          any insertion of 2 bases (or deletion of 2 bases) in the CDS\nrpoB@*_fs                           any frameshifting insertion or deletion in the CDS (notice that this is rpoB@*_ins_1 + rpoB@*_ins_2 + rpoB@*_ins_4 + rpoB@*_ins_5 +... and the same for deletions)\nrpoB@1300_indel                     any insertion or deletion at nucleotide 1300 in the CDS\nrpoB@1300_ins, rpoB@1300_del        any insertion (or deletion) at nucleotide 1300 in the CDS\nrpoB@1300_ins_2, rpoB@1300_del_2    any insertion of length 2 (or deletion of length 2) in the CDS\nrpoB@1300_ins_ca                    insertion of bases ca at position 1300 in the CDS (does not make sense for deletions)\n</code></pre> <p>Hence to specify any insertion that doesn't frame shift is susceptible, but any frame shifting insertions (i.e. introduces whole numbers of amino acids) confer resistance, whilst not enough deletions have been observed to classify. In addition insertions at position 1300 are classified as conferring resistance.</p> <pre><code>rpoB@*_ins    S\nrpoB@*_del    U\nrpoB@*_fs     R\nrpoB@1300_ins R\n</code></pre> <p>Here the hierarchy ensures that the susceptible insertions (or unknown deletions) that are actually frame shifts can overriden with an R.</p> <p>For promoters the picture is a bit more straightforward since there is no concept of a frame shift.</p> <pre><code>fabG1@-*_indel                      any insertion or deletion in the promoter of fabG1\nfabG1@-*_ins, fabG1@-*_del          any insertion (or deletion) in the promoter\nfabG1@-15_indel                     any insertion or deletion at nucleotide -15 in the promoter\nfabG1@-15_ins_2, fabG1@-15_del_2    any insertion of length 2 (or deletion of length 2) in the promoter\nfabG1@-15_ins_ca                    insertion of bases ca at position -15 in the promoter\n</code></pre>"},{"location":"nomenclature/#multi-mutations","title":"Multi-mutations","text":"<p>Any valid mutation can be joined to any other valid mutation by concatenating with <code>&amp;</code> to form a new valid mutation.</p> <p>Useful for cases which arrose from statistical testing of allelic variant calling, which found statistical links for cases which have &gt;1 mutation once parsed into GARC. As such, the individual mutations could not be utilised for predictions as the correlation was established with all mutations. Multi-mutations allow capture of such cases.</p> <pre><code>rpoB@S450L                          SNP within rpoB at position 450 S--&gt;L. Valid mutation\nrpoB@12_ins_aac                     Insert bases 'aac' at position 12 within rpoB. Valid mutation\nrpoB@12_ins_aac&amp;rpoB@S450L          Insert bases 'aac' at position 12 within rpoB AND a SNP in rpoB at position 450 S--&gt;L. Also a valid mutation\n</code></pre> <p>It is at the developer's discretion when to utilise this, but it is recommended that this is only used when necessary for a specific application (examples of which are below)</p> <p>This is also useful for cases in which different codon variations within a synonymous mutation confer different predictions - allowing specifying such mutations within a single row of a catalogue. It also retains the idea that this mutation is within a coding region of the gene, which is something which is not present if nucleotide changes are given.</p> <p>For example, if we want to show the following effects of <code>fabG1@L203L</code></p> <pre><code>If the change is `fabG1@g609a`, it confers `R`\nIf the change is `fabG1@c607t`, it confers `U`\nIf the change is anything else, it should confer `S` due to the default rule `gene@*=` confers `S`\n</code></pre> <p>Utilising this logic, we can produce the following rules:</p> <pre><code>`fabG1@L203L&amp;fabG1@g609a` confers `R`\n`fabG1@L203L&amp;fabG1@c607t` confers `U`\n`fabG1@L203L` confers `S`\n</code></pre> <p>As such, it is recommended that any synonymous mutations are treated as such when parsing into GARC.</p>"},{"location":"nomenclature/#epistasis-mutations","title":"Epistasis mutations","text":"<p>These are a subset of multi-mutations which have specific properties. Generally speaking, there should only be a single episasis rule which is hit by a given multi-mutation. This is due to prediction heierarchies falling apart in such cases, and these rules should be specific enough that it wouldn't make logical sense for more than one rule to be hit.</p> <p>Catalogue syntax:</p> <pre><code>^Rv0678@*_fs&amp;mmpl5@*_fs\n</code></pre> <p>Prediction syntax:</p> <pre><code>Any valid multi-mutation will be checked against epistasis rules.\n</code></pre>"},{"location":"nomenclature/#minor-populations","title":"Minor populations","text":"<p>GARC also allows for specification of a mutation being a minor population/minor allele.  E.g if a VCF has a row detailing coverage <code>98,2</code> with a <code>0/0</code> call, the call is a reference call, but there is also some evidence of an alt call (2 reads supporting this).</p> <p>In cases in which there are multiple minor population calls within a single codon (e.g we have minor calls for bases 1 and 2 of a codon), the coverage reported for the amino acid mutation should be the highest of the two.</p> <p>NOTE: Any minor call will not hit default rules if no specific rule exists for it.</p> <p>These can be conveyed in one of two ways:</p>"},{"location":"nomenclature/#coverage","title":"Coverage","text":"<p>Mutations can be defined by the number of reads which support this call: <code>rpoB@S450L:2</code> has exactly 2 reads supporting a mutation call of <code>rpoB@S450L</code></p>"},{"location":"nomenclature/#fractional-read-support","title":"Fractional read support","text":"<p>Mutations can also use FRS rather than coverage to support minor population calls. FRS is the fraction of all reads for this base which support this call: <code>reads supporting / total reads at this base</code>. In the above example, the FRS interpretation would be <code>rpoB@S450L:0.02</code></p> <p>NOTE: For consistency, it is recommended to only utilise one of these representations in a catalogue. <code>gumpy</code> is capable of generating mutations in both formats, but a catalogue of mixed coverage and FRS may cause some issues.</p>"},{"location":"nomenclature/#minor-multi-mutations","title":"Minor multi-mutations","text":"<p>As a minor population's muttion is a valid mutation in GARC, according to the <code>multi-mutation</code> rule, they can be chained together to provide a highly specific mutation.</p> <p>This may look like <code>rpoB@S450L:2&amp;rpoB@A451V:3</code></p>"},{"location":"nomenclature/#backusnaur-form-bnf","title":"Backus\u2013Naur form (BNF)","text":""},{"location":"nomenclature/#catalogue-bnf","title":"Catalogue BNF","text":"<p>This is a definition of the grammar acceptable to use within a catalogue. Where <code>&lt;gene-name&gt;</code> is any valid gene or locus name (usually matching the regex <code>[a-zA-Z0-9_]+</code>)</p> <pre><code>&lt;complete-mutation&gt; ::= &lt;partial-mutation&gt; | \"^\"&lt;partial-mutation&gt;\n&lt;partial-mutation&gt; ::= &lt;mutation&gt; | &lt;mutation&gt;\":\"&lt;number&gt; | &lt;mutation&gt;\":0.\"&lt;number&gt; | &lt;partial-mutation&gt;\"&amp;\"&lt;partial-mutation&gt;\n&lt;mutation&gt; ::= \n               &lt;gene-name&gt;\"@\"&lt;nucleotide&gt;&lt;position&gt;&lt;nucleotide&gt; | \n               &lt;gene-name&gt;\"@\"&lt;amino-acid&gt;&lt;number&gt;&lt;amino-acid&gt; |\n               &lt;gene-name&gt;\"@\"&lt;position&gt;\"_ins_\"&lt;nucleotides&gt; |\n               &lt;gene-name&gt;\"@\"&lt;position&gt;\"_ins_\"&lt;number&gt; |\n               &lt;gene-name&gt;\"@\"&lt;position&gt;\"_ins\" |\n               &lt;gene-name&gt;\"@\"&lt;position&gt;\"_del_\"&lt;nucleotides&gt; |\n               &lt;gene-name&gt;\"@\"&lt;position&gt;\"_del_\"&lt;number&gt; |\n               &lt;gene-name&gt;\"@\"&lt;position&gt;\"_del\" |\n               &lt;gene-name&gt;\"@\"&lt;position&gt;\"_indel\" |\n               &lt;gene-name&gt;\"@\"&lt;position&gt;\"_fs\" |\n               &lt;gene-name&gt;\"@\"&lt;pos-wildcard&gt;&lt;wildcard&gt; |\n               &lt;gene-name&gt;\"@\"&lt;nucleotide&gt;&lt;pos&gt;\"?\" |\n               &lt;gene-name&gt;\"@\"&lt;amino-acid&gt;&lt;number&gt;\"?\" |\n               &lt;gene-name&gt;\"@\"&lt;positive-position&gt;\"=\" |\n               &lt;gene-name&gt;\"@del_0.\"&lt;number&gt; |\n               &lt;gene-name&gt;\"@del_1.0\"\n\n&lt;wildcard&gt; ::= \"?\" | \"=\"\n\n&lt;positive-position&gt; ::= &lt;number&gt; | \"*\"\n\n&lt;position&gt; ::= &lt;pos&gt; | &lt;pos-wildcard&gt;\n\n&lt;pos-wildcard&gt; ::= \"*\" | \"-*\"\n\n&lt;pos&gt; ::= &lt;number&gt; | \"-\"&lt;number&gt;\n\n&lt;nucleotides&gt; ::= &lt;nucleotide&gt; | &lt;nucleotide&gt;&lt;nucleotide&gt;\n\n&lt;nucleotide&gt; ::= \"a\" | \"c\" | \"t\" | \"g\" | \"x\" | \"z\"\n\n&lt;amino-acid&gt; ::= \"A\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\" | \"!\"\n\n&lt;number&gt; ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" | &lt;number&gt;&lt;number&gt;\n</code></pre>"},{"location":"nomenclature/#prediction-bnf","title":"Prediction BNF","text":"<p>Due to wildcards not being intended for use for prediction (i.e it doesn't make sense to ask <code>piezo</code> to predict the effects of <code>rpoB@*?</code>), the grammar for prediction is slightly changed to reflect this. <code>&lt;gene-name&gt;</code> is still any valid gene or locus name (usually matching the regex <code>[a-zA-Z0-9_]+</code>)</p> <pre><code>&lt;complete-mutation&gt; ::= &lt;mutation&gt; | &lt;mutation&gt;\":\"&lt;number&gt; | &lt;mutation&gt;\":0.\"&lt;number&gt; | &lt;complete-mutation&gt;\"&amp;\"&lt;complete-mutation&gt;\n&lt;mutation&gt; ::= \n               &lt;gene-name&gt;\"@\"&lt;nucleotide&gt;&lt;pos&gt;&lt;nucleotide&gt; | \n               &lt;gene-name&gt;\"@\"&lt;amino-acid&gt;&lt;number&gt;&lt;amino-acid&gt; |\n               &lt;gene-name&gt;\"@\"&lt;pos&gt;\"_ins_\"&lt;nucleotides&gt; |\n               &lt;gene-name&gt;\"@\"&lt;pos&gt;\"_ins_\"&lt;number&gt; |\n               &lt;gene-name&gt;\"@\"&lt;pos&gt;\"_ins\" |\n               &lt;gene-name&gt;\"@\"&lt;pos&gt;\"_del_\"&lt;nucleotides&gt; |\n               &lt;gene-name&gt;\"@\"&lt;pos&gt;\"_del_\"&lt;number&gt; |\n               &lt;gene-name&gt;\"@\"&lt;pos&gt;\"_del\" |\n               &lt;gene-name&gt;\"@\"&lt;pos&gt;\"_indel\" |\n               &lt;gene-name&gt;\"@\"&lt;pos&gt;\"_fs\" |\n               &lt;gene-name&gt;\"@del_0.\"&lt;number&gt; |\n               &lt;gene-name&gt;\"@del_1.0\"\n\n&lt;pos&gt; ::= &lt;number&gt; | \"-\"&lt;number&gt;\n\n&lt;nucleotides&gt; ::= &lt;nucleotide&gt; | &lt;nucleotide&gt;&lt;nucleotide&gt;\n\n&lt;nucleotide&gt; ::= \"a\" | \"c\" | \"t\" | \"g\" | \"x\" | \"z\"\n\n&lt;amino-acid&gt; ::= \"A\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\" | \"!\"\n\n&lt;number&gt; ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" | &lt;number&gt;&lt;number&gt;\n</code></pre>"},{"location":"readme/","title":"Home","text":""},{"location":"readme/#piezo","title":"piezo","text":"<p>Predict the effect of a genetic mutation on the effect of an antibiotic using a supplied AMR catalogue.</p> <p>This code was developed as part of the CRyPTIC international tuberculosis consortium. If you would like to use the software commercially, please consult the LICENCE file.</p>"},{"location":"readme/#installation","title":"Installation","text":""},{"location":"readme/#using-pip","title":"Using <code>pip</code>","text":"<p>This will install the most recent release on PyPI.</p> <pre><code>pip install piezo\n</code></pre>"},{"location":"readme/#from-github","title":"From GitHub","text":"<p>This will install the current version from GitHub and therefore may be ahead of the PyPI version.</p> <pre><code>git clone https://github.com/oxfordmmm/piezo\ncd piezo\npip install .\n</code></pre> <p>The pre-requisites are all fairly standard and are listed in <code>setup.cfg</code> so will be automatically installed.</p>"},{"location":"readme/#documentation","title":"Documentation","text":"<p>API documentation for developers can be found here: https://oxfordmmm.github.io/piezo/</p>"},{"location":"readme/#included-files","title":"Included files","text":"<pre><code>$ ls tests/test-catalogue/\nNC_004148.2.gbk                    NC_004148.2_TEST_GM1_RFUS_v1.0.csv\n</code></pre> <p>NC_004148 is the reference genome of the human metapneumovirus and is used primarily for unit testing since it is small and fast to parse.</p>"},{"location":"readme/#design-of-amr-catalogue","title":"Design of AMR catalogue","text":"<p><code>piezo</code> is written so as to be extendable in the future to other ways of describing genetic variation with respect to a reference. It includes the concept of a <code>grammar</code> which specifies how the genetic variation is described.</p> <p>At present only a single grammar, <code>GARC1</code> is supported. <code>GARC</code> is short for Grammar for Antimicrobial Resistance Catalogues. This grammar is described in more detail elsewhere, however in brief, it is a gene-centric view (and therefore has no way of describing genetic variation that lies outside a coding region, other than as a 'promoter' mutation). All mutations start with the gene (or locus) name which must match the name of a gene (or locus) in the relevant GenBank file. It is the user's responsibility to ensure this, although e.g. the <code>gumpy</code> package can be used to perform such sanity checks. The mutation is delineated from the gene using a <code>@</code> symbol and within the mutation <code>_</code> is used as a field separator to separate the different components. All variation is described as either a <code>SNP</code> or an <code>INDEL</code>. If they occur within a coding region <code>SNP</code>s are specified by their effect on the amino acids which are always in UPPERCASE e.g. <code>rpoB@S450L</code>. If in the assumed promoter region, then the nucleotide change and position is specified e.g. <code>fabG1@c-15t</code>. Nucleotides are always in lowercase. <code>INDEL</code>s can be specified at different levels of granularity e.g. <code>rpoB@1250_indel</code> means 'any insertion of deletion at this position', but we could equally be highly specific and say <code>rpoB@1250_ins_cta</code> which means 'an insertion of cta at this position'. There is also the special case of frameshifting mutations which are described by <code>fs</code>.</p> <p>Wildcards are also supported. Hence <code>rpoB@*?</code> means 'any non-synoymous mutation in the coding region of the protein'. To avoid confusion the stop codon is represented by <code>!</code> which is non-standard. Het calls are, at present, represented by a <code>Z</code> or <code>z</code> depending on whether they occur in the coding or promoter regions. This may be extended in the future. Likewise null calls are represented by an <code>X</code> or <code>x</code>.</p> <p>The general principle is each mutation can 'hit' multiple rules in the catalogue, but it is the most specific rule that will be followed. Hence consider a toy example, again from TB</p> <pre><code>rpoB@*?     RIF   U   any non-synoymous mutation in the coding region has an unknown effect of RIF\nrpoB@S450?  RIF   R   any non-synoymous mutation at Ser450 confers resistance\nrpoB@S450Z  RIF   F   a het call at Ser450 should be reported as an F (fail).\n</code></pre>"},{"location":"readme/#example","title":"Example","text":"<p>A demonstration script called <code>piezo-predict.py</code> can be found in the <code>bin/</code> folder of the repository which following installation should be in your <code>$PATH</code>. A made-up catalogue for testing purposes can be found in <code>tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv</code> which is based on the Human metapneumovirus, however the entries are fictious. It contains two drugs and a series of mutations in the M2 gene.</p> <pre><code>$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@L73L\n{'DRUG_B': 'S', 'DRUG_A': 'S'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@L73R\n{'DRUG_A': 'R', 'DRUG_B': 'U'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@L73Z\n{'DRUG_B': 'S', 'DRUG_A': 'F'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_indel\n{'DRUG_B': 'U', 'DRUG_A': 'U'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_ins\n{'DRUG_B': 'U', 'DRUG_A': 'U'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_ins_2\n{'DRUG_B': 'U', 'DRUG_A': 'U'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_ins_3\n{'DRUG_A': 'U', 'DRUG_B': 'R'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_ins_4\n{'DRUG_B': 'U', 'DRUG_A': 'U'}\n\n$ piezo-predict.py --catalogue tests/test-catalogue/NC_004148.2_TEST_v1.0_GARC1_RFUS.csv --mutation M2@300_ins_cta\n{'DRUG_B': 'R', 'DRUG_A': 'U'}\n</code></pre>"},{"location":"reference/","title":"piezo","text":"<p>Piezo is an AMR prediction module. Logic for handling prediction values should reside within the catalogues.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>piezo</li> <li>catalogue</li> <li>grammar_GARC1</li> </ul>"},{"location":"reference/catalogue/","title":"catalogue","text":"<p>Instanciate the catalogue</p>"},{"location":"reference/catalogue/#catalogue.ResistanceCatalogue","title":"<code>ResistanceCatalogue</code>","text":"<p>Resistance catalogue loading</p> Source code in <code>piezo/catalogue.py</code> <pre><code>class ResistanceCatalogue:\n    \"\"\"Resistance catalogue loading\"\"\"\n\n    def __init__(self, catalogue_file: str, prediction_subset_only: bool = False):\n        \"\"\"Construct a resistance catalogue\n\n        Args:\n            catalogue_file (str): Path to the catalogue file\n            prediction_subset_only (bool, optional): Whether to use a subset of genes\n                to only resistance genes. Defaults to False.\n        \"\"\"\n        self.catalogue = load_catalogue(catalogue_file, prediction_subset_only)\n\n    def predict(\n        self, mutation: str, verbose: bool = False, show_evidence=False\n    ) -&gt; Dict[str, Tuple] | Dict[str, str] | str:\n        \"\"\"Make a prediction of a mutation's effects based on the catalogue\n\n        Args:\n            mutation (str): Mutation in GARC\n            verbose (bool, optional): Whether to be verbose.\n                Defaults to False. DEPRECIATED\n            show_evidence (bool, optional): If True predictions are returned as\n                (&lt;prediction&gt;, &lt;evidence&gt;)\n\n        Returns:\n            Dict[str, Tuple] | Dict[str, str] | str: Dictionary mapping drug name -&gt;\n                prediction, or if `show_evidence == True`, dictionary mapping drug\n                name -&gt; (prediction, evidence). If no susceptability is predicted, \"S\"\n        \"\"\"\n        if verbose:\n            warnings.warn(\n                \"`verbose` kwarg is depreciated and will be removed in future.\",\n                UserWarning,\n            )\n        return predict(\n            self.catalogue,\n            mutation=mutation,\n            verbose=verbose,\n            show_evidence=show_evidence,\n        )\n</code></pre>"},{"location":"reference/catalogue/#catalogue.ResistanceCatalogue.__init__","title":"<code>__init__(catalogue_file, prediction_subset_only=False)</code>","text":"<p>Construct a resistance catalogue</p> <p>Parameters:</p> Name Type Description Default <code>catalogue_file</code> <code>str</code> <p>Path to the catalogue file</p> required <code>prediction_subset_only</code> <code>bool</code> <p>Whether to use a subset of genes to only resistance genes. Defaults to False.</p> <code>False</code> Source code in <code>piezo/catalogue.py</code> <pre><code>def __init__(self, catalogue_file: str, prediction_subset_only: bool = False):\n    \"\"\"Construct a resistance catalogue\n\n    Args:\n        catalogue_file (str): Path to the catalogue file\n        prediction_subset_only (bool, optional): Whether to use a subset of genes\n            to only resistance genes. Defaults to False.\n    \"\"\"\n    self.catalogue = load_catalogue(catalogue_file, prediction_subset_only)\n</code></pre>"},{"location":"reference/catalogue/#catalogue.ResistanceCatalogue.predict","title":"<code>predict(mutation, verbose=False, show_evidence=False)</code>","text":"<p>Make a prediction of a mutation's effects based on the catalogue</p> <p>Parameters:</p> Name Type Description Default <code>mutation</code> <code>str</code> <p>Mutation in GARC</p> required <code>verbose</code> <code>bool</code> <p>Whether to be verbose. Defaults to False. DEPRECIATED</p> <code>False</code> <code>show_evidence</code> <code>bool</code> <p>If True predictions are returned as (, ) <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Tuple] | Dict[str, str] | str</code> <p>Dict[str, Tuple] | Dict[str, str] | str: Dictionary mapping drug name -&gt; prediction, or if <code>show_evidence == True</code>, dictionary mapping drug name -&gt; (prediction, evidence). If no susceptability is predicted, \"S\"</p> Source code in <code>piezo/catalogue.py</code> <pre><code>def predict(\n    self, mutation: str, verbose: bool = False, show_evidence=False\n) -&gt; Dict[str, Tuple] | Dict[str, str] | str:\n    \"\"\"Make a prediction of a mutation's effects based on the catalogue\n\n    Args:\n        mutation (str): Mutation in GARC\n        verbose (bool, optional): Whether to be verbose.\n            Defaults to False. DEPRECIATED\n        show_evidence (bool, optional): If True predictions are returned as\n            (&lt;prediction&gt;, &lt;evidence&gt;)\n\n    Returns:\n        Dict[str, Tuple] | Dict[str, str] | str: Dictionary mapping drug name -&gt;\n            prediction, or if `show_evidence == True`, dictionary mapping drug\n            name -&gt; (prediction, evidence). If no susceptability is predicted, \"S\"\n    \"\"\"\n    if verbose:\n        warnings.warn(\n            \"`verbose` kwarg is depreciated and will be removed in future.\",\n            UserWarning,\n        )\n    return predict(\n        self.catalogue,\n        mutation=mutation,\n        verbose=verbose,\n        show_evidence=show_evidence,\n    )\n</code></pre>"},{"location":"reference/catalogue/#catalogue.load_catalogue","title":"<code>load_catalogue(catalogue_file, prediction_subset_only)</code>","text":"<p>Read in the Antimicrobial Resistance Catalogue.</p> <p>Parameters:</p> Name Type Description Default <code>catalogue_file</code> <code>str</code> <p>path to a resistance catalogue as a CSV file in the correct format, as determined by its grammar</p> required <code>prediction_subset_only</code> <code>bool</code> <p>whether to subset the catalogue down so it ONLY includes entities (e.g. DRUG,GENE pairs) that include at least one row predicting resistance</p> required <p>Returns:</p> Name Type Description <code>catalogue</code> <code>namedtuple</code> <p>defined tuple</p> Notes <ul> <li>Applies checks to ensure the catalogue is in the right format.</li> </ul> Source code in <code>piezo/catalogue.py</code> <pre><code>def load_catalogue(catalogue_file: str, prediction_subset_only: bool) -&gt; Catalogue:\n    \"\"\"\n    Read in the Antimicrobial Resistance Catalogue.\n\n    Args:\n        catalogue_file (str): path to a resistance catalogue as a CSV file in the\n            correct format, as determined by its grammar\n        prediction_subset_only (bool): whether to subset the catalogue down so it ONLY\n            includes entities (e.g. DRUG,GENE pairs) that include at least one row\n            predicting resistance\n\n    Returns:\n        catalogue (collections.namedtuple): defined tuple\n\n    Notes:\n        * Applies checks to ensure the catalogue is in the right format.\n    \"\"\"\n\n    assert os.path.isfile(catalogue_file), (\n        \"supplied catalogue file \" + catalogue_file + \" does not exist!\"\n    )\n\n    rules = pandas.read_csv(\n        catalogue_file,\n        converters={\"OTHER\": parse_json, \"EVIDENCE\": parse_json, \"SOURCE\": parse_json},\n    )\n\n    assert (\n        len(rules.GENBANK_REFERENCE.unique()) == 1\n    ), \"multiple genbank references specified in catalogue!\"\n    genbank_reference = rules.GENBANK_REFERENCE.unique()[0]\n\n    assert (\n        len(rules.CATALOGUE_NAME.unique()) == 1\n    ), \"multiple catalogue models found in the catalogue!\"\n    name = rules.CATALOGUE_NAME.unique()[0]\n\n    assert (\n        len(rules.CATALOGUE_VERSION.unique()) == 1\n    ), \"multiple catalogue versions found in the catalogue!\"\n    version = rules.CATALOGUE_VERSION.unique()[0]\n\n    assert (\n        len(rules.CATALOGUE_GRAMMAR.unique()) == 1\n    ), \"multiple grammars found in the catalogue!\"\n    grammar = rules.CATALOGUE_GRAMMAR.unique()[0]\n\n    number_rows = len(rules)\n\n    assert (\n        len(rules.PREDICTION_VALUES.unique()) == 1\n    ), \"multiple grammar value types used in the catalogue!\"\n    values = rules.PREDICTION_VALUES.unique()[0]\n    if values in [\"RS\", \"RUS\", \"RFUS\"]:\n        values = [i for i in rules.PREDICTION_VALUES.unique()[0]]\n        assert sorted(values) == sorted(list(rules.PREDICTION.unique())), (\n            \"PREDICTION column contains entries not in \"\n            + rules.PREDICTION_VALUES.unique()[0]\n        )\n    else:\n        raise ValueError(\"content of column CATALOGUE_VALUES not recognised!\")\n\n    # since we are storing the above values in the named tuple, we don't need them in\n    #   the rules dataframe\n    rules.drop(\n        columns=[\n            \"GENBANK_REFERENCE\",\n            \"CATALOGUE_NAME\",\n            \"CATALOGUE_VERSION\",\n            \"CATALOGUE_GRAMMAR\",\n            \"PREDICTION_VALUES\",\n        ],\n        inplace=True,\n    )\n\n    # find out the DRUGS that this catalogue applies to\n    drugs = list(rules.DRUG.unique())\n\n    if grammar != \"GARC1\":\n        raise ValueError(\"only the GENE_MUTATION grammar is supported at present!\")\n\n    elif grammar == \"GARC1\":\n        (rules, genes, drug_lookup, gene_lookup) = process_catalogue_GARC1(\n            rules, drugs, catalogue_genes_only=prediction_subset_only\n        )\n\n    return Catalogue(\n        genbank_reference,\n        name,\n        version,\n        grammar,\n        values,\n        drugs,\n        genes,\n        drug_lookup,\n        gene_lookup,\n        number_rows,\n        rules,\n    )\n</code></pre>"},{"location":"reference/catalogue/#catalogue.parse_json","title":"<code>parse_json(data)</code>","text":"<p>Load the data within a json string to Python dict</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the JSON data</p> Source code in <code>piezo/catalogue.py</code> <pre><code>def parse_json(data: str) -&gt; dict:\n    \"\"\"Load the data within a json string to Python dict\n\n    Args:\n        data (str): JSON string\n\n    Returns:\n        dict: Dictionary of the JSON data\n    \"\"\"\n\n    return ujson.loads(data)\n</code></pre>"},{"location":"reference/catalogue/#catalogue.predict","title":"<code>predict(catalogue, mutation, verbose=False, show_evidence=False)</code>","text":"<p>Predict the effect of the given mutation on one or more antimicrobials.</p> <p>Parameters:</p> Name Type Description Default <code>catalogue</code> <code>namedtuple</code> <p>The catalogue</p> required <code>mutation</code> <code>str</code> <p>a genetic variant in the form GENE_MUTATION e.g. for a SNP katG@S315T, INDEL katG@315_indel.</p> required <code>verbose</code> <code>bool</code> <p>if True, then a description of the rules that apply to the supplied mutation and their priority is written to STDOUT (default=False). DEPRECIATED</p> <code>False</code> <code>show_evidence</code> <code>bool</code> <p>If True, predictions are returned as a tuple of (, ). Default=False <code>False</code> <p>Returns:</p> Name Type Description <code>result</code> <code>dict</code> <p>the drugs affected by the mutation are the keys, and the predicted phenotypes are the values. e.g. {'LEV':'R', 'MXF':'R'} if the gene isn't in the catalogue, then an \"S\" is returned, on the assumption that it is probably susceptible.</p> Notes <ul> <li>mutations can be specified in a grammar that covers most of the known and     expected genetic variants.</li> <li>Stop codon is represented by \"!\"</li> <li>\"any mutation at position S315\" (i.e. a wildcard) is represented by \"?\"     e.g. S315?</li> <li>for more info see the walkthrough and also the NOMENCLATURE.md file</li> </ul> Source code in <code>piezo/catalogue.py</code> <pre><code>def predict(\n    catalogue: Catalogue,\n    mutation: str,\n    verbose: bool = False,\n    show_evidence: bool = False,\n) -&gt; Dict[str, Tuple] | Dict[str, str] | str:\n    \"\"\"\n    Predict the effect of the given mutation on one or more antimicrobials.\n\n    Args:\n        catalogue (collections.namedtuple): The catalogue\n        mutation (str): a genetic variant in the form GENE_MUTATION e.g. for a SNP\n            katG@S315T, INDEL katG@315_indel.\n        verbose (bool): if True, then a description of the rules that apply to the\n            supplied mutation and their priority is written to STDOUT\n            (default=False). DEPRECIATED\n        show_evidence (bool, optional): If True, predictions are returned as a tuple of\n            (&lt;prediciton&gt;, &lt;evidence&gt;). Default=False\n\n    Returns:\n        result (dict): the drugs affected by the mutation are the keys, and the\n            predicted phenotypes are the values. e.g. {'LEV':'R', 'MXF':'R'}\n            if the gene isn't in the catalogue, then an \"S\" is returned, on the\n            assumption that it is probably susceptible.\n\n    Notes:\n        * mutations can be specified in a grammar that covers most of the known and\n            expected genetic variants.\n        * Stop codon is represented by \"!\"\n        * \"any mutation at position S315\" (i.e. a wildcard) is represented by \"?\"\n            e.g. S315?\n        * for more info see the walkthrough and also the NOMENCLATURE.md file\n    \"\"\"\n    if verbose:\n        warnings.warn(\n            \"`verbose` kwarg is depreciated and will be removed in future.\", UserWarning\n        )\n\n    return predict_GARC1(catalogue, mutation, show_evidence=show_evidence)\n</code></pre>"},{"location":"reference/grammar_GARC1/","title":"grammar_GARC1","text":"<p>All logic required to parse and generate predictions from a catalogue in GARC1</p>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.infer_mutation_affects","title":"<code>infer_mutation_affects(position)</code>","text":"<p>Find out which part of the gene this position affects</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>Gene position</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Either \"PROM\" or \"CDS\"</p> Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def infer_mutation_affects(position: int) -&gt; str:\n    \"\"\"Find out which part of the gene this position affects\n\n    Args:\n        position (int): Gene position\n\n    Returns:\n        str: Either \"PROM\" or \"CDS\"\n    \"\"\"\n\n    if position &lt; 0:\n        mutation_affects = \"PROM\"\n    else:\n        mutation_affects = \"CDS\"\n    return mutation_affects\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.large_del","title":"<code>large_del(predictions, rules, size, minor)</code>","text":"<p>Row prediction, but specifically for large deletions</p> <p>Parameters:</p> Name Type Description Default <code>predictions</code> <code>{int</code> <p>str}): Predictions dictionary</p> required <code>rules</code> <code>DataFrame</code> <p>Rules from the catalogue</p> required <code>size</code> <code>float</code> <p>Percentage of the gene deleted (as a decimal)</p> required <code>minor</code> <code>float</code> <p>Minors (if existing)</p> required Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def large_del(\n    predictions: Dict[int, Tuple[str, Dict]],\n    rules: pandas.DataFrame,\n    size: float,\n    minor: float | None,\n) -&gt; None:\n    \"\"\"Row prediction, but specifically for large deletions\n\n    Args:\n        predictions ({int: str}): Predictions dictionary\n        rules (pandas.DataFrame): Rules from the catalogue\n        size (float): Percentage of the gene deleted (as a decimal)\n        minor (float): Minors (if existing)\n    \"\"\"\n    pred = None\n    current: float = -1\n    # Find which rules are large deletions and see if the mutation is &gt;= rule\n    deletion = re.compile(r\"\"\"del_([01]\\.[0-9]+)\"\"\")\n    for _, rule in rules.iterrows():\n        del_match = deletion.fullmatch(rule[\"MUTATION\"])\n        if del_match is not None:\n            percentage = float(del_match.groups()[0])\n            if size &gt;= percentage and percentage &gt; current:\n                # Match!\n                if minor is None and rule[\"MINOR\"] == \"\":\n                    # Neither are minor populations so act normally\n                    pred = rule[\"PREDICTION\"]\n                    evidence = rule[\"EVIDENCE\"]\n                    current = percentage\n                elif (\n                    minor is not None\n                    and rule[\"MINOR\"] != \"\"\n                    and minor &lt; 1\n                    and float(rule[\"MINOR\"]) &lt; 1\n                ):\n                    # We have FRS\n                    if minor &gt;= float(rule[\"MINOR\"]):\n                        # Match\n                        pred = rule[\"PREDICTION\"]\n                        evidence = rule[\"EVIDENCE\"]\n                        current = percentage\n\n                elif (\n                    minor is not None\n                    and rule[\"MINOR\"] != \"\"\n                    and minor &gt;= 1\n                    and float(rule[\"MINOR\"]) &gt;= 1\n                ):\n                    # We have COV\n                    if minor &gt;= float(rule[\"MINOR\"]):\n                        # Match\n                        pred = rule[\"PREDICTION\"]\n                        evidence = rule[\"EVIDENCE\"]\n                        current = percentage\n    if pred:\n        predictions[1] = (str(pred), evidence)\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.match_multi","title":"<code>match_multi(rule, mutation, catalogue)</code>","text":"<p>Determine if a given mutation matches a given rule. This takes into account wildcards.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Series</code> <p>Rule to check for</p> required <code>mutation</code> <code>str</code> <p>Mutation to check for</p> required <code>catalogue</code> <code>Catalogue</code> <p>Catalogue this rule is from</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this mutation matches the rule</p> Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def match_multi(rule: pandas.Series, mutation: str, catalogue: Catalogue) -&gt; bool:\n    \"\"\"Determine if a given mutation matches a given rule.\n    This takes into account wildcards.\n\n    Args:\n        rule (pandas.Series): Rule to check for\n        mutation (str): Mutation to check for\n        catalogue (Catalogue): Catalogue this rule is from\n\n    Returns:\n        bool: True if this mutation matches the rule\n    \"\"\"\n    if rule[\"MUTATION\"] == mutation:\n        # Literal match\n        return True\n\n    rule_mutations = rule[\"MUTATION\"].split(\"&amp;\")\n\n    if len(rule_mutations) != len(mutation.split(\"&amp;\")):\n        # Not same number of mutations in the rule so not a match\n        return False\n\n    # Bit more tricky here as we need to check that every part of the mutation matches\n    #   a single part of the rule\n    # do this by constructing a dummy catalogue from the multi-rule and checking each\n    #   part of the mutation hits it\n\n    # First create a catalogue with just the rules in this multi\n    dummy_cat = {\n        \"EVIDENCE\": [\n            ujson.dumps({\"Rule hit\": idx}) for (idx, _) in enumerate(rule_mutations)\n        ],\n        \"MUTATION\": rule_mutations,\n        \"DRUG\": [\"na\" for _ in rule_mutations],\n        \"PREDICTION\": [\"R\" for _ in rule_mutations],\n    }\n    r = pandas.DataFrame(dummy_cat)\n    r[\n        [\"GENE\", \"MUTATION\", \"POSITION\", \"MUTATION_AFFECTS\", \"MUTATION_TYPE\", \"MINOR\"]\n    ] = r.apply(split_mutation, axis=1)\n\n    # As this is a named **tuple**, it is immutable so create a new one\n    cat = Catalogue(\n        catalogue.genbank_reference,\n        catalogue.name,\n        catalogue.version,\n        catalogue.grammar,\n        \"R\",  # Obviously not R but RFUS are needed here\n        [\"na\"],\n        r[\"GENE\"].tolist(),\n        {\"na\": r[\"GENE\"].tolist()},\n        {gene: [\"na\"] for gene in r[\"GENE\"].tolist()},\n        len(r),\n        r,\n    )\n\n    for mut in mutation.split(\"&amp;\"):\n        try:\n            pred = predict_GARC1(cat, mut, True)\n            if isinstance(pred, str):\n                # pred == \"S\":\n                # No results so not matched\n                return False\n\n            # Pull out the multi-rule index this hit from the evidence\n            pred_ev = ujson.loads(pred[\"na\"][1])\n\n            rule_idx = int(pred_ev[\"Rule hit\"])\n            r.drop([rule_idx], inplace=True)\n\n            # Rebuild the catalogue object with the updated rule set\n            cat = Catalogue(\n                catalogue.genbank_reference,\n                catalogue.name,\n                catalogue.version,\n                catalogue.grammar,\n                \"R\",  # Obviously not R but RFUS are needed here\n                [\"na\"],\n                r[\"GENE\"].tolist(),\n                {\"na\": r[\"GENE\"].tolist()},\n                {gene: [\"na\"] for gene in r[\"GENE\"].tolist()},\n                len(r),\n                r,\n            )\n        except ValueError:\n            # No rules for this drugs etc\n            return False\n\n    if len(r) == 0:\n        # Must have matched every rule in the multi\n        return True\n\n    # Not matched everything, so not a match\n    return False\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.merge_predictions","title":"<code>merge_predictions(predictions, catalogue)</code>","text":"<p>When multi-mutations do not have a hit, they are decomposed and individuals are     tried instead This merges these predictions based on the prioritisation defined for this catalogue</p> <p>Parameters:</p> Name Type Description Default <code>predictions</code> <code>{str</code> <p>{str: str}}): Dictionary mapping mutation -&gt; effects for each mutation in the multi</p> required <code>catalogue</code> <code>namedtuple</code> <p>The catalogue object (for finding the values)</p> required <p>Returns:     {str: str}: Merged effects dict mapping drug name -&gt; prediction. Or \"S\" if         no matches</p> Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def merge_predictions(\n    predictions: Dict[str, Dict[str, Tuple] | Dict[str, str]], catalogue: Catalogue\n) -&gt; Dict[str, Tuple] | str:\n    \"\"\"When multi-mutations do not have a hit, they are decomposed and individuals are\n        tried instead\n    This merges these predictions based on the prioritisation defined for this catalogue\n\n    Args:\n        predictions ({str: {str: str}}): Dictionary mapping mutation -&gt; effects for\n            each mutation in the multi\n        catalogue (collections.namedtuple): The catalogue object\n            (for finding the values)\n    Returns:\n        {str: str}: Merged effects dict mapping drug name -&gt; prediction. Or \"S\" if\n            no matches\n    \"\"\"\n    # Pull out all of the drugs which have predictions\n    drugs = set()\n    for pred in predictions:\n        for drug in predictions[pred].keys():\n            drugs.add(drug)\n\n    # Default to 'S' for now\n    merged: Dict[str, Tuple] = {drug: (\"S\", dict()) for drug in drugs}\n\n    # Look for all predictions for each drug, and report the most significant\n    for drug in drugs:\n        for mutation in predictions.keys():\n            # Get the prediction for this drug (if exists)\n            this_pred = predictions[mutation][drug]\n\n            if isinstance(this_pred, str):\n                continue\n            else:\n                pred, evidence = this_pred\n\n            if catalogue.values.index(pred) &lt;= catalogue.values.index(merged[drug][0]):\n                # New highest priority, so set the prediction\n                merged[drug] = (pred, evidence)\n\n    # If we have &gt;=1 non-'S' prediction, return the dict\n    if len([key for key in merged.keys() if merged[key][0] != \"S\"]) &gt; 0:\n        return {drug: merged[drug] for drug in merged.keys() if merged[drug][0] != \"S\"}\n\n    # Else give the default 'S'\n    return \"S\"\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.parse_mutation","title":"<code>parse_mutation(mutation)</code>","text":"<p>Take a GENE_MUTATION, and determine what type it is, what it affects etc</p> <p>Parameters:</p> Name Type Description Default <code>mutation</code> <code>str</code> <p>in the gene_mutation form as defined by GARC e.g. rpoB@S450L or rpoB@1300_ins_3</p> required <p>Returns:</p> Name Type Description <code>position</code> <code>int</code> <p>the position of the mutation. This is the amino acid number in a protein, or the number of the nucleotide in the promoter, or a wildcard like '' or '-'</p> <code>mutation_affects</code> <code>str</code> <p>whether this mutation affects the promoter (PROM) or coding sequence (CDS)</p> <code>mutation_type</code> <code>str</code> <p>is it a SNP or an INDEL?</p> <code>indel_type</code> <code>str</code> <p>indel, ins, del or fs</p> <code>indel_length</code> <code>float</code> <p>if sufficient information is given, the number of bases in the INDEL</p> <code>indel_bases</code> <code>str</code> <p>if sufficient information is given, the bases in the INDEL</p> <code>before</code> <code>str</code> <p>the REF amino acid</p> <code>after</code> <code>str</code> <p>the ALT amino acid</p> Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def parse_mutation(\n    mutation: str,\n) -&gt; list[\n    Tuple[\n        int | None,\n        str | None,\n        str,\n        str | None,\n        float | None,\n        str | None,\n        str | None,\n        str | None,\n    ]\n]:\n    \"\"\"\n    Take a GENE_MUTATION, and determine what type it is, what it affects etc\n\n    Args:\n        mutation (str): in the gene_mutation form as defined by GARC e.g. rpoB@S450L or\n            rpoB@1300_ins_3\n\n    Returns:\n        position (int): the position of the mutation. This is the amino acid number in\n            a protein, or the number of the nucleotide in the promoter, or a\n            wildcard like '*' or '-*'\n        mutation_affects (str): whether this mutation affects the promoter (PROM) or\n            coding sequence (CDS)\n        mutation_type (str): is it a SNP or an INDEL?\n        indel_type (str): indel, ins, del or fs\n        indel_length (float): if sufficient information is given, the number of bases\n            in the INDEL\n        indel_bases (str): if sufficient information is given, the bases in the INDEL\n        before (str): the REF amino acid\n        after (str): the ALT amino acid\n\n    \"\"\"\n\n    # set default values\n    mutation_type = None\n    mutation_affects = None\n    position = None\n    indel_type = None\n    indel_length = None\n    indel_bases = None\n    before = None\n    after = None\n\n    # split the mutation on underscore\n    cols = mutation.split(\"_\")\n\n    # infer what type it is depending on how many elements it contains\n    if len(cols) == 1:\n        mutation_type = \"SNP\"\n\n        position = int(mutation[1:-1])\n\n        mutation_affects = infer_mutation_affects(position)\n\n        before = mutation[0]\n        after = mutation[-1]\n\n    elif len(cols) in [2, 3]:\n        mutation_type = \"INDEL\"\n        # Checking for large deletions\n        percentage = False\n        if cols[0] == \"del\":\n            try:\n                float(cols[1])\n                percentage = True\n            except ValueError:\n                percentage = False\n\n        if percentage:\n            mutation_affects = \"GENE\"\n            indel_type = \"del\"\n            indel_length = float(cols[1])\n        else:\n            try:\n                position = int(cols[0])\n            except ValueError:\n                assert False, \"Invalid mutation: \" + mutation\n            mutation_affects = infer_mutation_affects(position)\n\n            # the third element is one of indel, ins, del or the special case fs\n            indel_type = cols[1]\n\n            assert indel_type in [\"indel\", \"ins\", \"del\", \"fs\", \"mixed\"], (\n                \"form of indel not recognised: \" + indel_type\n            )\n\n            # if there is a fourth and final element to an INDEL it is either _4 or\n            #    _ctgc\n            if len(cols) == 3:\n                assert indel_type in [\"ins\", \"del\"], (\n                    \"form of indel does not make sense when length \"\n                    + \"or bases specified!: \"\n                    + indel_type\n                )\n                try:\n                    indel_length = int(cols[2])\n                except ValueError:\n                    indel_length = len(cols[2])\n                    indel_bases = cols[2]\n                    assert 0 not in [\n                        c in [\"a\", \"t\", \"c\", \"g\", \"z\", \"x\"] for c in indel_bases\n                    ], \"only nucleotides of a,t,c,g,z,x are allowed!\"\n\n                assert indel_length &gt; 0, (\n                    \"makes no sense to have a negative indel length! \" + cols[2]\n                )\n\n    assert mutation_type in [\n        \"INDEL\",\n        \"SNP\",\n    ], \"form of mutation_type not recognised: \" + str(mutation_type)\n\n    # insist we've been given an amino acid or a wildcard only\n    if mutation_type == \"SNP\":\n        sanity_check_snp(before, after)\n\n    parsed = [\n        (\n            position,\n            mutation_affects,\n            mutation_type,\n            indel_type,\n            indel_length,\n            indel_bases,\n            before,\n            after,\n        )\n    ]\n    if (\n        mutation_affects == \"PROM\"\n        and indel_type == \"del\"\n        and indel_length is not None\n        and position is not None\n    ):\n        # Potential case of deletion crossing into coding region\n        if position + indel_length &gt; 0:\n            new_bases = (\n                indel_bases[abs(position) :] if indel_bases is not None else None\n            )\n            parsed.append(\n                (\n                    1,\n                    \"CDS\",\n                    \"INDEL\",\n                    \"del\",\n                    position + indel_length,\n                    new_bases,\n                    before,\n                    after,\n                )\n            )\n    return parsed\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.predict","title":"<code>predict(catalogue, gene, mutation, gene_mutation, drugs, result, show_evidence, minor, position, mutation_affects, mutation_type, indel_type, indel_length, indel_bases, before, after)</code>","text":"<p>Given a parsed mutation, predict effects for it.</p> <p>Parameters:</p> Name Type Description Default <code>catalogue</code> <code>Catalogue</code> <p>Catalogue to predict from</p> required <code>gene</code> <code>str</code> <p>Gene name</p> required <code>mutation</code> <code>str</code> <p>Mutation in GARC</p> required <code>gene_mutation</code> <code>str</code> <p>Joined gene and mutation (for error messages)</p> required <code>drugs</code> <code>List[str]</code> <p>List of drugs to check for</p> required <code>result</code> <code>Dict[str, Tuple]</code> <p>Cumulative results of predictions</p> required <code>show_evidence</code> <code>bool</code> <p>Whether to show predictions</p> required <code>minor</code> <code>float | None</code> <p>Minor population supporting this mutation</p> required <code>position</code> <code>int</code> <p>Position this mutation affects</p> required <code>mutation_affects</code> <code>str</code> <p>Where this mutation affects (CDS or PROM)</p> required <code>mutation_type</code> <code>str</code> <p>Type of mutations (INDEL or SNP)</p> required <code>indel_type</code> <code>str</code> <p>Type of indel (INS or DEL)</p> required <code>indel_length</code> <code>int</code> <p>Length of indel (if any)</p> required <code>indel_bases</code> <code>str</code> <p>Bases inserted or deleted (if any)</p> required <code>before</code> <code>str</code> <p>Before SNP (if any)</p> required <code>after</code> <code>str</code> <p>After SNP (if any)</p> required <p>Returns:</p> Type Description <code>Dict[str, Tuple] | str</code> <p>Dict[str, Tuple] | Dict[str, str]: Results of predictions</p> Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def predict(\n    catalogue: Catalogue,\n    gene: str,\n    mutation: str,\n    gene_mutation: str,\n    drugs: List[str],\n    result: Dict[str, Tuple],\n    show_evidence: bool,\n    minor: float | None,\n    position: int | None,\n    mutation_affects: str | None,\n    mutation_type: str | None,\n    indel_type: str | None,\n    indel_length: float | None,\n    indel_bases: str | None,\n    before: str | None,\n    after: str | None,\n) -&gt; Dict[str, Tuple] | str:\n    \"\"\"Given a parsed mutation, predict effects for it.\n\n    Args:\n        catalogue (Catalogue): Catalogue to predict from\n        gene (str): Gene name\n        mutation (str): Mutation in GARC\n        gene_mutation (str): Joined gene and mutation (for error messages)\n        drugs (List[str]): List of drugs to check for\n        result (Dict[str, Tuple]): Cumulative results of predictions\n        show_evidence (bool): Whether to show predictions\n        minor (float | None): Minor population supporting this mutation\n        position (int): Position this mutation affects\n        mutation_affects (str): Where this mutation affects (CDS or PROM)\n        mutation_type (str): Type of mutations (INDEL or SNP)\n        indel_type (str): Type of indel (INS or DEL)\n        indel_length (int): Length of indel (if any)\n        indel_bases (str): Bases inserted or deleted (if any)\n        before (str): Before SNP (if any)\n        after (str): After SNP (if any)\n\n    Returns:\n        Dict[str, Tuple] | Dict[str, str]: Results of predictions\n    \"\"\"\n    # create the vectors of Booleans that will apply\n    position_vector = catalogue.rules.POSITION.isin(\n        [position, str(position), \"*\", \"-*\"]\n    )\n    mutation_affects_vector = catalogue.rules.MUTATION_AFFECTS == mutation_affects\n    mutation_type_vector = catalogue.rules.MUTATION_TYPE == mutation_type\n    gene_vector = catalogue.rules.GENE == gene\n    subset_vector = (\n        position_vector &amp; mutation_affects_vector &amp; mutation_type_vector &amp; gene_vector\n    )\n    # deal with each compound, one at a time\n    for compound in drugs:\n        subset_rules = catalogue.rules.loc[\n            (subset_vector) &amp; (catalogue.rules.DRUG == compound)\n        ]\n\n        # prepare a dictionary to store hits with the priority as the key:\n        #   e.g. {10:'R',5:'U'}\n        predictions: Dict[int, Tuple[str, Dict]] = {}\n\n        if not subset_rules.empty:\n            subset_position_vector = subset_rules.POSITION == str(position)\n            subset_mutation_type_vector = subset_rules.MUTATION_TYPE == mutation_type\n\n            if mutation_type == \"SNP\":\n                process_snp_variants(\n                    mutation_affects,\n                    predictions,\n                    before,\n                    after,\n                    mutation,\n                    subset_rules,\n                    subset_mutation_type_vector,\n                    subset_position_vector,\n                    minor,\n                )\n            elif mutation_type == \"INDEL\":\n                process_indel_variants(\n                    mutation_affects,\n                    predictions,\n                    subset_rules,\n                    subset_mutation_type_vector,\n                    subset_position_vector,\n                    indel_length,\n                    indel_type,\n                    indel_bases,\n                    position,\n                    minor,\n                )\n\n        if not predictions:\n            # all mutations should hit at least one of the default entries, so if this\n            #   doesn't happen, something is wrong UNLESS the mutation given is a minor allele\n            if \":\" in gene_mutation:\n                result[compound] = (\"S\", {})\n            elif mutation_type == \"SNP\" and after in [\"X\", \"x\"]:\n                # Null call with no specific row matches, so return S\n                # as it doesn't make sense to match defaults for a null call\n                result[compound] = (\"S\", {})\n            else:\n                raise ValueError(\n                    \"No entry found in the catalogue for \"\n                    + gene_mutation\n                    + \" \"\n                    + compound\n                )\n        else:\n            final_prediction: Tuple = predictions[sorted(predictions)[-1]]\n            result[compound] = final_prediction\n\n    return result\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.predict_GARC1","title":"<code>predict_GARC1(catalogue, gene_mutation, show_evidence=False)</code>","text":"<p>For the GARC1 grammar, predict the effect of the supplied gene_mutation.</p> <p>Parameters:</p> Name Type Description Default <code>catalogue</code> <code>namedtuple</code> <p>defines the resistance catalogue</p> required <code>gene_mutation</code> <code>str</code> <p>as specified by the GARC1 grammar, e.g. rpoB@S450L, fabG1@c-15t, ahpC@128_indel</p> required <code>show_evidence</code> <code>bool</code> <p>Flag for whether to return the evidence for this prediction</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Tuple] | Dict[str, str] | str</code> <p>{str: (str, str) | str} | str: Either a dictionary mapping drug name -&gt; (prediction, evidence) if show_evidence is True or \"S\" if no hits in the catalogue</p> Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def predict_GARC1(\n    catalogue: Catalogue, gene_mutation: str, show_evidence: bool = False\n) -&gt; Dict[str, Tuple] | Dict[str, str] | str:\n    \"\"\"\n    For the GARC1 grammar, predict the effect of the supplied gene_mutation.\n\n    Args:\n        catalogue (collections.namedtuple): defines the resistance catalogue\n        gene_mutation (str): as specified by the GARC1 grammar, e.g. rpoB@S450L,\n            fabG1@c-15t, ahpC@128_indel\n        show_evidence (bool, optional): Flag for whether to return the evidence for\n            this prediction\n\n    Returns:\n        {str: (str, str) | str} | str: Either a dictionary mapping drug name -&gt;\n            (prediction, evidence) if show_evidence is True or \"S\" if no hits\n            in the catalogue\n    \"\"\"\n\n    # create the result dictionary e.g. {\"RIF\":'R', \"RFB\":'R'}\n    # most of the time the predictions will be identical, but this allows them to\n    #   diverge in future\n    result: Dict[str, Tuple] = {}\n\n    if \"&amp;\" in gene_mutation:\n        # Multi-gene so treat differently\n        result_multi: Dict[str, Tuple] | str = predict_multi(catalogue, gene_mutation)\n        if show_evidence or isinstance(result_multi, str):\n            return result_multi\n        else:\n            return {key: result_multi[key][0] for key in result_multi.keys()}\n\n    components = gene_mutation.split(\"@\")\n\n    gene = components[0]\n    mutation = gene_mutation.split(gene + \"@\")[1]\n\n    # Check for minors\n    if \":\" in mutation:\n        try:\n            minor = float(mutation.split(\":\")[-1])\n        except ValueError:\n            assert False, \"Malformed mutation! \" + mutation\n        mutation = mutation.split(\":\")[0]\n        assert minor &gt; 0, \"Minor population given with no evidence! \" + mutation\n    else:\n        minor = None\n\n    # parse the mutation to work out what type of mutation it is, where it acts etc\n    parsed_mutations = parse_mutation(mutation)\n\n    # if the gene isn't in the catalogue, then assume it has no effect\n    if gene not in catalogue.genes:\n        return \"S\"\n\n    # find out the drugs to which changes in this gene can confer resistance\n    drugs = catalogue.gene_lookup[gene]\n\n    for (\n        position,\n        mutation_affects,\n        mutation_type,\n        indel_type,\n        indel_length,\n        indel_bases,\n        before,\n        after,\n    ) in parsed_mutations:\n        res = predict(\n            catalogue,\n            gene,\n            mutation,\n            gene_mutation,\n            drugs,\n            result,\n            show_evidence,\n            minor,\n            position,\n            mutation_affects,\n            mutation_type,\n            indel_type,\n            indel_length,\n            indel_bases,\n            before,\n            after,\n        )\n\n        if not isinstance(res, str):\n            result = res\n\n    # Null calls need a little nudge to ensure that they are correctly handled if they don't hit any rules\n    if mutation_type == \"SNP\" and after in [\"X\", \"x\"]:\n        all_default_nulls = True\n        for drug in drugs:\n            if result[drug] != (\"S\", {}):\n                all_default_nulls = False\n        if all_default_nulls:\n            return \"S\"\n\n    if show_evidence or isinstance(result, str):\n        return result\n    else:\n        return {key: result[key][0] for key in result.keys()}\n\n    return result\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.predict_multi","title":"<code>predict_multi(catalogue, gene_mutation)</code>","text":"<p>Get the predictions for a given multi-mutation. Mutli-mutations are (currently) a lot stricter than others, and do not support     wildcards or subsets of the mutations</p> <p>Parameters:</p> Name Type Description Default <code>catalogue</code> <code>namedtuple</code> <p>The resistance catalogue</p> required <code>gene_mutation</code> <code>str</code> <p>String of the mutations, each in GARC, separated by <code>&amp;</code></p> required <p>Returns:     {str: str} | str : Either a dict with drugs as the keys, or 'S' when no         predictions in catalogue</p> Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def predict_multi(catalogue: Catalogue, gene_mutation: str) -&gt; Dict[str, Tuple] | str:\n    \"\"\"Get the predictions for a given multi-mutation.\n    Mutli-mutations are (currently) a lot stricter than others, and do not support\n        wildcards or subsets of the mutations\n\n    Args:\n        catalogue (collections.namedtuple): The resistance catalogue\n        gene_mutation (str): String of the mutations, each in GARC, separated by `&amp;`\n    Returns:\n        {str: str} | str : Either a dict with drugs as the keys, or 'S' when no\n            predictions in catalogue\n    \"\"\"\n    # Ensure that the mutations are in a reproducable order\n    sorted_mutation = \"&amp;\".join(sorted(list(gene_mutation.split(\"&amp;\"))))\n\n    # Check for minor populations (and remove, we'll check these separately)\n    minors = [\n        float(mut.split(\":\")[-1]) if \":\" in mut else None\n        for mut in sorted_mutation.split(\"&amp;\")\n    ]\n    sorted_mutation = \"&amp;\".join(\n        [mut.split(\":\")[0] for mut in sorted_mutation.split(\"&amp;\")]\n    )\n\n    # Check epistasis first\n    epi_rules = catalogue.rules[catalogue.rules[\"MUTATION_TYPE\"] == \"EPISTASIS\"]\n    # Note the use of \"\" here instead of \"{}\" to allow empty evidence fields\n    epi_drugs = {drug: (\"S\", \"\") for drug in catalogue.drugs}\n    values = catalogue.values\n    for _, rule in epi_rules.iterrows():\n        if match_multi(rule, sorted_mutation, catalogue):\n            # Epistasis rule hit\n            drug = rule[\"DRUG\"]\n            if epi_drugs[drug][1] != \"\":\n                # This drug already has an epistasis rule hit so throw an error\n                raise ValueError(\n                    f\"Conflicting epistasis rules for {gene_mutation}:{drug}! \"\n                    \"Check your catalogue!\"\n                )\n            # Valid, so check for minors\n            for cat, minor in zip(rule[\"MINOR\"].split(\",\"), minors):\n                if minor is None and cat == \"\":\n                    # Neither are minors so add\n                    epi_drugs[drug] = (rule[\"PREDICTION\"], rule[\"EVIDENCE\"])\n                elif cat != \"\" and minor is not None and minor &lt; 1 and float(cat) &lt; 1:\n                    # FRS\n                    if minor &gt;= float(cat):\n                        # Match\n                        epi_drugs[drug] = (rule[\"PREDICTION\"], rule[\"EVIDENCE\"])\n                elif cat != \"\" and minor is not None and minor &gt;= 1 and float(cat) &gt;= 1:\n                    # COV\n                    if minor &gt;= float(cat):\n                        # Match\n                        epi_drugs[drug] = (rule[\"PREDICTION\"], rule[\"EVIDENCE\"])\n\n    # Get the multi rules\n    multi_rules = catalogue.rules[catalogue.rules[\"MUTATION_TYPE\"] == \"MULTI\"]\n\n    drugs = {drug: (\"S\", \"{}\") for drug in catalogue.drugs}\n    for _, rule in multi_rules.iterrows():\n        drug = rule[\"DRUG\"]\n        if epi_drugs[drug][1] != \"\":\n            # Epistasis rule already covers this, so skip it\n            continue\n        if match_multi(rule, sorted_mutation, catalogue):\n            # We have a match! Prioritise predictions based on values\n            if values.index(rule[\"PREDICTION\"]) &lt; values.index(drugs[drug][0]):\n                # The prediction is closer to the start of the values list, so should\n                #   take priority\n                # Check for minor populations first though\n                for cat, minor in zip(rule[\"MINOR\"].split(\",\"), minors):\n                    if minor is None and cat == \"\":\n                        # Neither are minors so add\n                        drugs[drug] = (rule[\"PREDICTION\"], rule[\"EVIDENCE\"])\n                    elif (\n                        cat != \"\" and minor is not None and minor &lt; 1 and float(cat) &lt; 1\n                    ):\n                        # FRS\n                        if minor &gt;= float(cat):\n                            # Match\n                            drugs[drug] = (rule[\"PREDICTION\"], rule[\"EVIDENCE\"])\n                    elif (\n                        cat != \"\"\n                        and minor is not None\n                        and minor &gt;= 1\n                        and float(cat) &gt;= 1\n                    ):\n                        # COV\n                        if minor &gt;= float(cat):\n                            # Match\n                            drugs[drug] = (rule[\"PREDICTION\"], rule[\"EVIDENCE\"])\n\n    # Check to ensure we have at least 1 prediction\n    if len([key for key in epi_drugs.keys() if epi_drugs[key][1] != \"\"]) &gt; 0:\n        # Epistasis hit(s) so join with the multis\n        to_return = drugs\n        for drug in epi_drugs:\n            if epi_drugs[drug][1] != \"\":\n                # This drug has an epi match\n                to_return[drug] = epi_drugs[drug]\n            elif drugs[drug][0] == \"S\":\n                # Drop default `S` predictions\n                del to_return[drug]\n        # For whatever reason, this appeases mypy\n        return {key: value for key, value in to_return.items()}\n\n    if len([key for key in drugs.keys() if drugs[key][0] != \"S\"]) &gt; 0:\n        # At least one multi hit\n        return {drug: drugs[drug] for drug in drugs.keys() if drugs[drug][0] != \"S\"}\n\n    # Nothing predicted, so try each individual mutation\n    predictions = {}\n    for mutation, minor in zip(sorted_mutation.split(\"&amp;\"), minors):\n        # Put minor populations back into mutations as required\n        if minor is not None:\n            mutation = mutation + \":\" + str(minor)\n\n        # Get the prediction for the mutation\n        pred = predict_GARC1(catalogue, mutation, True)\n        if isinstance(pred, str):\n            # We have a 'S' prediction so ignore it\n            continue\n        else:\n            predictions[mutation] = pred\n\n    return merge_predictions(predictions, catalogue)\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.process_catalogue_GARC1","title":"<code>process_catalogue_GARC1(rules, drugs, catalogue_genes_only)</code>","text":"<p>For the GARC1 grammar, add some additional columns to the rules dataframe that     can be inferred from the mutation.</p> <p>Parameters:</p> Name Type Description Default <code>rules</code> <code>DataFrame</code> <p>Pandas dataframe of the AMR catalogue in the general form</p> required <code>drugs</code> <code>[str]</code> <p>list of drugs in the AMR catalogue</p> required <code>catalogue_genes_only</code> <code>bool</code> <p>whether to subset the catalogue down so it ONLY includes (DRUG,GENE) pairs that include at least one row predicting resistance</p> required <p>Returns:     (pandas.DataFrame, [str], {str: [str]}, {str: [str]}) : Tuple of values.         In order:             DataFrame of the rules             List of the genes             Dictionary mapping drug name -&gt; [gene names]             Dictionary mapping gene name -&gt; [drug names]</p> Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def process_catalogue_GARC1(\n    rules: pandas.DataFrame, drugs: List[str], catalogue_genes_only: bool\n) -&gt; Tuple[pandas.DataFrame, List[str], Dict[str, List[str]], Dict[str, List[str]]]:\n    \"\"\"\n    For the GARC1 grammar, add some additional columns to the rules dataframe that\n        can be inferred from the mutation.\n\n    Args:\n        rules (pandas.DataFrame): Pandas dataframe of the AMR catalogue in the\n            general form\n        drugs ([str]): list of drugs in the AMR catalogue\n        catalogue_genes_only (bool): whether to subset the catalogue down so it ONLY\n            includes (DRUG,GENE) pairs that include at least one row predicting\n            resistance\n    Returns:\n        (pandas.DataFrame, [str], {str: [str]}, {str: [str]}) : Tuple of values.\n            In order:\n                DataFrame of the rules\n                List of the genes\n                Dictionary mapping drug name -&gt; [gene names]\n                Dictionary mapping gene name -&gt; [drug names]\n\n    \"\"\"\n\n    # infer these columns\n    rules[\n        [\"GENE\", \"MUTATION\", \"POSITION\", \"MUTATION_AFFECTS\", \"MUTATION_TYPE\", \"MINOR\"]\n    ] = rules.apply(split_mutation, axis=1)\n\n    if catalogue_genes_only:\n        # create an index of which (drug,gene) pairs have at least one row predicting\n        #   resistance or uncertainty\n        drug_list_index = (\n            rules.loc[(rules.PREDICTION == \"R\") | (rules.PREDICTION == \"U\")][\n                [\"DRUG\", \"GENE\"]\n            ]\n            .groupby([\"DRUG\", \"GENE\"])\n            .count()\n        )\n\n        # Exclude multi/epistasis rules from this as epistasis rules override R\n        multis = rules[\n            (rules[\"MUTATION_TYPE\"] == \"EPISTASIS\")\n            | (rules[\"MUTATION_TYPE\"] == \"MULTI\")\n        ]\n\n        # index the rules so we can right join\n        rules.set_index([\"DRUG\", \"GENE\"], inplace=True)\n\n        # do the right join; this has the effect of removing all the rows for\n        #   \"genes of interest\"\n        rules = rules.join(drug_list_index, how=\"right\")\n\n        # remove the index\n        rules.reset_index(inplace=True)\n\n        # Add back multi/epistais rules now\n        rules = pandas.concat([rules, multis])\n        # Some multis (but not all) can be duplicated here, so drop duplicate entries\n        # Note that drop_duplicates doesn't like the JSON columns, so de-duplicate on other fields\n        rules.drop_duplicates(\n            inplace=True,\n            subset=[\n                \"DRUG\",\n                \"GENE\",\n                \"MUTATION\",\n                \"POSITION\",\n                \"MUTATION_AFFECTS\",\n                \"MUTATION_TYPE\",\n                \"MINOR\",\n            ],\n        )\n\n    # create a list of the genes mentioned in the catalogue\n    genes = list(rules.GENE.unique())\n\n    # create a dictionary where the genes are keys and the entries tell which drugs\n    #   are affected\n    gene_lookup = {}\n    for gene_name in genes:\n        df = rules.loc[rules.GENE == gene_name]\n        gene_lookup[gene_name] = sorted(list(df.DRUG.unique()))\n\n    # create a dictionary where the drugs are keys and the entries tell which genes\n    #   are affected\n    drug_lookup = {}\n    for drug_name in drugs:\n        df = rules.loc[rules.DRUG == drug_name]\n        drug_lookup[drug_name] = list(df.GENE.unique())\n\n    return rules, genes, drug_lookup, gene_lookup\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.process_indel_variants","title":"<code>process_indel_variants(mutation_affects, predictions, rules, rules_mutation_type_vector, rules_position_vector, indel_length, indel_type, indel_bases, position, minor)</code>","text":"<p>Apply the cascading rules for INDELs in GARC</p> <p>Parameters:</p> Name Type Description Default <code>mutation_affects</code> <code>str</code> <p>Which area this mutation affects. i.e PROM/CDS</p> required <code>predictions</code> <code>{int</code> <p>str}): Dictionary mapping priority -&gt; prediction. This is updated for implict return</p> required <code>rules</code> <code>DataFrame</code> <p>Rules DataFrame</p> required <code>rules_mutation_type_vector</code> <code>Series</code> <p>Series for the rules which refer to this mutation type</p> required <code>rules_position_vector</code> <code>Series</code> <p>Series for the rules which refer to this position</p> required <code>indel_length</code> <code>int</code> <p>Length of the indel</p> required <code>indel_type</code> <code>str</code> <p>Type of the indel. i.e ins/del/fs/indel</p> required <code>indel_bases</code> <code>str</code> <p>Bases inserted/deleted (if applicable)</p> required <code>position</code> <code>int</code> <p>Position of the indel</p> required <code>minor</code> <code>float</code> <p>Float for supporting evidence of minor populations (or None if not a minor population)</p> required Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def process_indel_variants(\n    mutation_affects: str | None,\n    predictions: Dict[int, Tuple[str, Dict]],\n    rules: pandas.DataFrame,\n    rules_mutation_type_vector: pandas.Series,\n    rules_position_vector: pandas.Series,\n    indel_length: float | None,\n    indel_type: str | None,\n    indel_bases: str | None,\n    position: int | None,\n    minor: float | None,\n) -&gt; None:\n    \"\"\"Apply the cascading rules for INDELs in GARC\n\n    Args:\n        mutation_affects (str): Which area this mutation affects. i.e PROM/CDS\n        predictions ({int: str}): Dictionary mapping priority -&gt; prediction. This is\n            updated for implict return\n        rules (pandas.DataFrame): Rules DataFrame\n        rules_mutation_type_vector (pandas.Series): Series for the rules which refer\n            to this mutation type\n        rules_position_vector (pandas.Series): Series for the rules which refer to\n            this position\n        indel_length (int): Length of the indel\n        indel_type (str): Type of the indel. i.e ins/del/fs/indel\n        indel_bases (str): Bases inserted/deleted (if applicable)\n        position (int): Position of the indel\n        minor (float): Float for supporting evidence of minor populations (or None if\n            not a minor population)\n    \"\"\"\n    if mutation_affects == \"GENE\" and indel_length is not None:\n        # Large deletions are priority 1\n        large_del(\n            predictions, rules.loc[rules_mutation_type_vector], indel_length, minor\n        )\n\n    # PRIORITY 1: any insertion or deletion in the CDS or PROM (e.g. rpoB@*_indel\n    #   or rpoB@-*_indel)\n    if mutation_affects == \"CDS\":\n        row = rules.loc[\n            rules_mutation_type_vector\n            &amp; ((rules.MUTATION == \"*_indel\") | (rules.MUTATION == \"*_mixed\"))\n        ]\n    else:\n        row = rules.loc[\n            rules_mutation_type_vector\n            &amp; ((rules.MUTATION == \"-*_indel\") | (rules.MUTATION == \"-*mixed\"))\n        ]\n    # any insertion or deletion in the CDS or PROM\n    row_prediction(row, predictions, 1, minor)\n\n    # PRIORITY 2: rpoB@*_ins, rpoB@*_del any insertion (or deletion) in the CDS or PROM\n    if indel_type is not None:\n        if mutation_affects == \"CDS\":\n            row = rules.loc[\n                rules_mutation_type_vector &amp; (rules.MUTATION.isin([\"*_\" + indel_type]))\n            ]\n        else:\n            row = rules.loc[\n                rules_mutation_type_vector &amp; (rules.MUTATION.isin([\"-*_\" + indel_type]))\n            ]\n        # any insertion (or deletion) in the CDS or PROM\n        row_prediction(row, predictions, 2, minor)\n\n    # PRIORITY 3: any insertion of a specified length (or deletion) in the CDS or PROM\n    #   (e.g. rpoB@*_ins_2, rpoB@*_del_3, rpoB@-*_ins_1, rpoB@-*_del_200)\n    if indel_length is not None and indel_type is not None and indel_type != \"indel\":\n        if mutation_affects == \"CDS\":\n            row = rules.loc[\n                rules_mutation_type_vector\n                &amp; (rules.MUTATION.isin([\"*_\" + indel_type + \"_\" + str(indel_length)]))\n            ]\n        else:\n            row = rules.loc[\n                rules_mutation_type_vector\n                &amp; (rules.MUTATION.isin([\"-*_\" + indel_type + \"_\" + str(indel_length)]))\n            ]\n        # any insertion of a specified length (or deletion) in the CDS or PROM\n        row_prediction(row, predictions, 3, minor)\n\n    # PRIORITY=4: any frameshifting insertion or deletion in the CDS (e.g. rpoB@*_fs)\n    if indel_length is not None and (indel_length % 3) != 0:\n        row = rules.loc[rules_mutation_type_vector &amp; (rules.MUTATION == \"*_fs\")]\n        # any frameshifting insertion or deletion in the CDS\n        row_prediction(row, predictions, 4, minor)\n\n    # PRIORITY=5: any indel at a specific position in the CDS or PROM\n    #   (e.g. rpoB@1300_indel or rpoB@-15_indel)\n    row = rules.loc[\n        rules_mutation_type_vector\n        &amp; rules_position_vector\n        &amp; (rules.MUTATION.str.contains(\"indel\"))\n    ]\n    # any indel at a specific position in the CDS or PROM (e.g. rpoB@1300_indel\n    #   or rpoB@-15_indel)\n    row_prediction(row, predictions, 5, minor)\n\n    # PRIORITY=6: an insertion (or deletion) at a specific position in the CDS or PROM\n    #   (e.g. rpoB@1300_ins or rpoB@-15_del)\n    if indel_type != \"indel\" and indel_type is not None:\n        row = rules.loc[\n            rules_mutation_type_vector\n            &amp; rules_position_vector\n            &amp; (rules.MUTATION.str.contains(indel_type))\n        ]\n        # any insertion (or deletion) at a specific position in the CDS or PROM\n        #   (e.g. rpoB@1300_ins or rpoB@-15_del)\n        row_prediction(row, predictions, 6, minor)\n\n    # PRIORITY=7: an insertion (or deletion) of a specified length at a specific\n    #   position in the CDS or PROM (e.g. rpoB@1300_ins_2 or rpoB@-15_del_200)\n    if indel_type != \"indel\" and indel_type is not None and indel_length is not None:\n        row = rules.loc[\n            rules_mutation_type_vector\n            &amp; rules_position_vector\n            &amp; (\n                rules.MUTATION\n                == str(position) + \"_\" + indel_type + \"_\" + str(indel_length)\n            )\n        ]\n        # an insertion (or deletion) of a specified length at a specific position in\n        #   the CDS or PROM (e.g. rpoB@1300_ins_2 or rpoB@-15_del_200)\n        row_prediction(row, predictions, 7, minor)\n\n    # PRIORITY=8: a frameshifting mutation at a specific position in the CDS\n    #   (e.g. rpoB@100_fs)\n    if indel_length is not None and (indel_length % 3) != 0 and position is not None:\n        row = rules.loc[\n            rules_mutation_type_vector\n            &amp; rules_position_vector\n            &amp; (rules.MUTATION == str(position) + \"_fs\")\n        ]\n        # a frameshifting mutation at a specific position in the CDS (e.g. rpoB@100_fs)\n        row_prediction(row, predictions, 8, minor)\n\n    # PRIORITY=9: an insertion of a specified series of nucleotides at a position in\n    #   the CDS or PROM (e.g. rpoB@1300_ins_ca)\n    if indel_type == \"ins\" and indel_length is not None and indel_bases is not None:\n        row = rules.loc[\n            rules_mutation_type_vector\n            &amp; rules_position_vector\n            &amp; (rules.MUTATION == str(position) + \"_ins_\" + indel_bases)\n        ]\n        # an insertion of a specified series of nucleotides at a position in the CDS or\n        #   PROM (e.g. rpoB@1300_ins_ca)\n        row_prediction(row, predictions, 9, minor)\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.process_snp_variants","title":"<code>process_snp_variants(mutation_affects, predictions, before, after, mutation, rules, rules_mutation_type_vector, rules_position_vector, minor)</code>","text":"<p>Apply cascading rules for SNPs according to GARC</p> <p>Parameters:</p> Name Type Description Default <code>mutation_affects</code> <code>str</code> <p>Where this mutation affects. i.e PROM/CDS</p> required <code>predictions</code> <code>{int</code> <p>str}): Predictions dictionary mapping priority -&gt; prediction. This is updated for implict return</p> required <code>before</code> <code>str</code> <p>Reference base/AA</p> required <code>after</code> <code>str</code> <p>Alt base/AA</p> required <code>mutation</code> <code>str</code> <p>Mutation in GARC</p> required <code>rules</code> <code>DataFrame</code> <p>Rules DataFrame</p> required <code>rules_mutation_type_vector</code> <code>Series</code> <p>Series relating to rules for this type of mutation</p> required <code>rules_position_vector</code> <code>Series</code> <p>Series relating to rules for this position</p> required <code>minor</code> <code>float | None</code> <p>Float for supporting evidence of minor populations (or None if not a minor population).</p> required Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def process_snp_variants(\n    mutation_affects: str | None,\n    predictions: Dict[int, Tuple[str, Dict]],\n    before: str | None,\n    after: str | None,\n    mutation: str,\n    rules: pandas.DataFrame,\n    rules_mutation_type_vector: pandas.Series,\n    rules_position_vector: pandas.Series,\n    minor: float | None,\n) -&gt; None:\n    \"\"\"Apply cascading rules for SNPs according to GARC\n\n    Args:\n        mutation_affects (str): Where this mutation affects. i.e PROM/CDS\n        predictions ({int: str}): Predictions dictionary mapping priority -&gt; prediction.\n            This is updated for implict return\n        before (str): Reference base/AA\n        after (str): Alt base/AA\n        mutation (str): Mutation in GARC\n        rules (pandas.DataFrame): Rules DataFrame\n        rules_mutation_type_vector (pandas.Series): Series relating to rules for this\n            type of mutation\n        rules_position_vector (pandas.Series): Series relating to rules for this\n            position\n        minor (float | None): Float for supporting evidence of minor populations\n            (or None if not a minor population).\n    \"\"\"\n\n    if before == after:\n        # PRIORITY=0: no change, i.e. wildtype specified\n\n        # PRIORITY=1: synonymous mutation at any position in the CDS (e.g. rpoB_*=)\n        row = rules.loc[rules_mutation_type_vector &amp; (rules.MUTATION == \"*=\")]\n        # syn SNP at any position in the CDS\n        row_prediction(row, predictions, 1, minor)\n\n    elif before != after:\n        # PRIORITY=2: nonsynoymous mutation at any position in the CDS or PROM\n        #   (e.g. rpoB_*? or rpoB_-*?)\n        if mutation[-1] not in [\"X\", \"x\"]:\n            # Don't let null calls hit default rules\n            if mutation_affects == \"CDS\":\n                row = rules.loc[rules_mutation_type_vector &amp; (rules.MUTATION == \"*?\")]\n                # nonsyn SNP at any position in the CDS\n                row_prediction(row, predictions, 2, minor)\n            else:\n                row = rules.loc[rules_mutation_type_vector &amp; (rules.MUTATION == \"-*?\")]\n                # nonsyn SNP at any position in the PROM\n                row_prediction(row, predictions, 2, minor)\n        # PRIORITY=3: het mutation at any position in the CDS or PROM (e.g. rpoB@*Z\n        #   or rpoB@-*z)\n        if mutation[-1] in [\"Z\", \"z\", \"O\", \"o\", \"X\", \"x\"]:\n            if mutation_affects == \"CDS\":\n                if mutation[-1] == \"Z\":\n                    row = rules.loc[\n                        (rules_mutation_type_vector) &amp; (rules.MUTATION == \"*Z\")\n                    ]\n                    # het SNP at any position in the CDS\n                    row_prediction(row, predictions, 3, minor)\n                elif mutation[-1] == \"O\":\n                    row = rules.loc[\n                        (rules_mutation_type_vector) &amp; (rules.MUTATION == \"*O\")\n                    ]\n                    # filter fail at any position in the CDS\n                    row_prediction(row, predictions, 3, minor)\n                elif mutation[-1] == \"X\":\n                    row = rules.loc[\n                        (rules_mutation_type_vector) &amp; (rules.MUTATION == \"*X\")\n                    ]\n                    # null at any position in the CDS\n                    row_prediction(row, predictions, 3, minor)\n            else:\n                if mutation[-1] == \"z\":\n                    row = rules.loc[\n                        rules_mutation_type_vector &amp; (rules.MUTATION == \"-*z\")\n                    ]\n                    # het SNP at any position in the PROM\n                    row_prediction(row, predictions, 3, minor)\n                elif mutation[-1] == \"o\":\n                    row = rules.loc[\n                        rules_mutation_type_vector &amp; (rules.MUTATION == \"-*o\")\n                    ]\n                    # filter fail at any position in the PROM\n                    row_prediction(row, predictions, 3, minor)\n                elif mutation[-1] == \"x\":\n                    row = rules.loc[\n                        rules_mutation_type_vector &amp; (rules.MUTATION == \"-*x\")\n                    ]\n                    # null at any position in the PROM\n                    row_prediction(row, predictions, 3, minor)\n\n        # PRIORITY=4: specific mutation at any position in the CDS: only Stop codons\n        #   make sense for now (e.g. rpoB@*!)\n        if mutation[-1] in [\"!\"]:\n            if mutation_affects == \"CDS\":\n                row = rules.loc[rules_mutation_type_vector &amp; (rules.MUTATION == \"*!\")]\n                # stop codon at any position in the CDS\n                row_prediction(row, predictions, 4, minor)\n\n        # PRIORITY=5: no change at specific position\n        # PRIORITY=6: synonymous mutations at specific location (usually picked up by\n        #   e.g. L202L, rather than L202=)\n\n        # PRIORITY=7: any het mutation at this specific position in the CDS or PROM\n        #   (e.g. rpoB@S450Z or rpoB@c-15z)\n        if mutation[-1] in [\"Z\", \"z\"]:\n            row = rules.loc[\n                (rules_mutation_type_vector)\n                &amp; (rules_position_vector)\n                &amp; (rules.MUTATION.str[-1].isin([\"Z\", \"z\"]))\n            ]\n            # het SNP at specified position in the CDS\n            row_prediction(row, predictions, 7, minor)\n\n        # PRIORITY=8: any nonsynoymous mutation at this specific position in the CDS or\n        #   PROM  (e.g. rpoB@S450? or rpoB@c-15?)\n        if mutation[-1] not in [\"X\", \"x\"]:\n            row = rules.loc[\n                rules_mutation_type_vector\n                &amp; rules_position_vector\n                &amp; (rules.MUTATION.str[-1] == \"?\")\n            ]\n            # nonsyn SNP at specified position in the CDS\n            row_prediction(row, predictions, 8, minor)\n\n    # PRIORITY=9: an exact match\n    row = rules.loc[(rules_mutation_type_vector) &amp; (rules.MUTATION == mutation)]\n    # exact SNP match\n    row_prediction(row, predictions, 9, minor)\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.row_prediction","title":"<code>row_prediction(rows, predictions, priority, minor)</code>","text":"<p>Get the predictions from the catalogue for the applicable rows</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>DataFrame</code> <p>DataFrame of the rows within the catalogue</p> required <code>predictions</code> <code>dict</code> <p>Predictions dict mapping priorities to predictions. This is updated for implict return</p> required <code>priority</code> <code>int</code> <p>Priority of this mutation type</p> required <code>minor</code> <code>float | None</code> <p>Reads/FRS supporting this, or None if not a minor population</p> required Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def row_prediction(\n    rows: pandas.DataFrame,\n    predictions: Dict[int, Tuple[str, Dict]],\n    priority: int,\n    minor: float | None,\n) -&gt; None:\n    \"\"\"Get the predictions from the catalogue for the applicable rows\n\n    Args:\n        rows (pandas.DataFrame): DataFrame of the rows within the catalogue\n        predictions (dict): Predictions dict mapping priorities to predictions. This is\n            updated for implict return\n        priority (int): Priority of this mutation type\n        minor (float | None): Reads/FRS supporting this, or None if not a\n            minor population\n    \"\"\"\n    pred = None\n    evidence = dict()\n    values = [\"R\", \"U\", \"F\", \"S\", None]\n    for _, row in rows.iterrows():\n        if not row.empty:\n            assert int(priority) in range(\n                1, 11\n            ), \"priority must be an integer in range 1,2..10\"\n            if values.index(row[\"PREDICTION\"]) &lt; values.index(pred):\n                # This row's prediction is more important than the current, so check\n                #   for minors and prioritise\n                if minor is None and row[\"MINOR\"] == \"\":\n                    # Neither are minor populations so act normally\n                    pred = row[\"PREDICTION\"]\n                    evidence = row[\"EVIDENCE\"]\n\n                elif (\n                    minor is not None\n                    and row[\"MINOR\"] != \"\"\n                    and minor &lt; 1\n                    and float(row[\"MINOR\"]) &lt; 1\n                ):\n                    # We have FRS\n                    if minor &gt;= float(row[\"MINOR\"]):\n                        # Match\n                        pred = row[\"PREDICTION\"]\n                        evidence = row[\"EVIDENCE\"]\n\n                elif (\n                    minor is not None\n                    and row[\"MINOR\"] != \"\"\n                    and minor &gt;= 1\n                    and float(row[\"MINOR\"]) &gt;= 1\n                ):\n                    # We have COV\n                    if minor &gt;= float(row[\"MINOR\"]):\n                        # Match\n                        pred = row[\"PREDICTION\"]\n                        evidence = row[\"EVIDENCE\"]\n    if pred:\n        predictions[int(priority)] = (str(pred), evidence)\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.sanity_check_snp","title":"<code>sanity_check_snp(before, after)</code>","text":"<p>Sanity check that a given SNP is valid. i.e check that the bases are valid</p> <p>Parameters:</p> Name Type Description Default <code>before</code> <code>str</code> <p>Reference bases/AA</p> required <code>after</code> <code>str</code> <p>Alt bases/AA</p> required <p>Raises:</p> Type Description <code>AssertationError</code> <p>Raised in cases in which the SNP is invalid.</p> Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def sanity_check_snp(before: str | None, after: str | None) -&gt; None:\n    \"\"\"Sanity check that a given SNP is valid. i.e check that the bases are valid\n\n    Args:\n        before (str): Reference bases/AA\n        after (str): Alt bases/AA\n\n    Raises:\n        AssertationError: Raised in cases in which the SNP is invalid.\n    \"\"\"\n\n    assert after in [\n        \"a\",\n        \"c\",\n        \"t\",\n        \"g\",\n        \"x\",\n        \"z\",\n        \"o\",\n        \"?\",\n        \"!\",\n        \"A\",\n        \"C\",\n        \"D\",\n        \"E\",\n        \"F\",\n        \"G\",\n        \"H\",\n        \"I\",\n        \"K\",\n        \"L\",\n        \"M\",\n        \"N\",\n        \"O\",\n        \"P\",\n        \"Q\",\n        \"R\",\n        \"S\",\n        \"T\",\n        \"V\",\n        \"W\",\n        \"X\",\n        \"Y\",\n        \"Z\",\n    ], (\n        str(after) + \" is not a recognised amino acid or base!\"\n    )\n    assert before in [\n        \"a\",\n        \"c\",\n        \"t\",\n        \"g\",\n        \"?\",\n        \"!\",\n        \"A\",\n        \"C\",\n        \"D\",\n        \"E\",\n        \"F\",\n        \"G\",\n        \"H\",\n        \"I\",\n        \"K\",\n        \"L\",\n        \"M\",\n        \"N\",\n        \"P\",\n        \"Q\",\n        \"R\",\n        \"S\",\n        \"T\",\n        \"V\",\n        \"W\",\n        \"Y\",\n    ], (\n        str(before) + \" is not a recognised amino acid or base!\"\n    )\n\n    if before.islower():\n        assert after.islower(), \"nucleotides must be lowercase!\"\n        assert (\n            before != after\n        ), \"makes no sense for the nucleotide to be the same in a mutation!\"\n    elif before.isupper():\n        assert after.isupper() or after == \"!\", \"amino acids must be UPPERCASE!\"\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.split_mutation","title":"<code>split_mutation(row)</code>","text":"<p>Take a row of the catalogue and get info about the mutation from it. This includes the type, ref, alt, position and minor populations</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>Series</code> <p>Catalogue row</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised when mutations are malformed</p> <p>Returns:</p> Type Description <code>Series</code> <p>pandas.Series: Series about the mutation. In order: gene, mutation, position, type of position (i.e PROM/CDS), mutation type (i.e INDEL/SNP/MULTI), support for minor populations</p> Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def split_mutation(row: pandas.Series) -&gt; pandas.Series:\n    \"\"\"Take a row of the catalogue and get info about the mutation from it.\n    This includes the type, ref, alt, position and minor populations\n\n    Args:\n        row (pandas.Series): Catalogue row\n\n    Raises:\n        ValueError: Raised when mutations are malformed\n\n    Returns:\n        pandas.Series: Series about the mutation. In order: gene, mutation, position,\n            type of position (i.e PROM/CDS), mutation type (i.e INDEL/SNP/MULTI),\n            support for minor populations\n    \"\"\"\n    # Strip any whitespace as this can cause issues\n    row[\"MUTATION\"] = row[\"MUTATION\"].strip()\n    if \"&amp;\" in row[\"MUTATION\"]:\n        # Multi-mutation so don't try to split it out in the same way\n        gene = \"MULTI\"\n\n        if row[\"MUTATION\"][0] == \"^\":\n            mutation_type = \"EPISTASIS\"\n            row[\"MUTATION\"] = row[\"MUTATION\"][1::]\n        else:\n            mutation_type = \"MULTI\"\n\n        # Ensure mutations are in a reproducable order\n        mutation = \"&amp;\".join(sorted(list(row[\"MUTATION\"].split(\"&amp;\"))))\n\n        position = None\n        mutation_affects = None\n\n        # Check for minor populations (and remove, we'll check these separately)\n        minors = \",\".join(\n            [mut.split(\":\")[-1] if \":\" in mut else \"\" for mut in mutation.split(\"&amp;\")]\n        )\n\n        mutation = \"&amp;\".join([mut.split(\":\")[0] for mut in mutation.split(\"&amp;\")])\n\n        # Check for validity\n        validate_multi(mutation)\n\n        return pandas.Series(\n            [gene, mutation, position, mutation_affects, mutation_type, minors]\n        )\n\n    # split the supplied mutation on _ which separates the components\n    components = row[\"MUTATION\"].split(\"@\")\n\n    # the gene name is always the first component\n    gene = components[0]\n\n    # ..and the remainder is the mutation\n    mutation = row[\"MUTATION\"].split(gene + \"@\")[1]\n\n    # Check for minor populations (and remove minors, we'll check for those separately)\n    if \":\" in mutation:\n        minor = mutation.split(\":\")[-1]\n        mutation = mutation.split(\":\")[0]\n    else:\n        minor = \"\"\n\n    cols = mutation.split(\"_\")\n    valid = True\n\n    if len(cols) == 1:\n        mutation_type = \"SNP\"\n        mutation_affects = \"CDS\"\n        try:\n            position = cols[0][1:-1]\n            if int(position) &lt; 0:\n                mutation_affects = \"PROM\"\n            elif int(position) == 0:\n                valid = False\n        except ValueError:\n            position = cols[0][:-1]\n            if position[0] == \"-\":\n                mutation_affects = \"PROM\"\n\n    elif len(cols) in [2, 3]:\n        mutation_type = \"INDEL\"\n        percentage = False\n        if len(cols) == 2:\n            # Checking for percentage deletions (of form \"del_&lt;percent&gt;\")\n            try:\n                float(cols[1])\n                percentage = True\n            except ValueError:\n                percentage = False\n            if percentage:\n                position = None\n        if percentage:\n            mutation_affects = \"GENE\"\n        else:\n            mutation_affects = \"CDS\"\n            position = cols[0]\n            try:\n                if int(position) &lt; 0:\n                    mutation_affects = \"PROM\"\n                elif int(position) == 0:\n                    valid = False\n            except ValueError:\n                try:\n                    if position[0] == \"-\":\n                        mutation_affects = \"PROM\"\n                except IndexError:\n                    valid = False\n\n    else:\n        raise ValueError(\"Badly formed mutation: \" + row[\"MUTATION\"])\n\n    if not valid:\n        # Valid mutation not found, so complain\n        raise ValueError(\"Badly formed mutation: \" + row[\"MUTATION\"])\n\n    return pandas.Series(\n        [gene, mutation, position, mutation_affects, mutation_type, minor]\n    )\n</code></pre>"},{"location":"reference/grammar_GARC1/#grammar_GARC1.validate_multi","title":"<code>validate_multi(mutation)</code>","text":"<p>Validate that we have a valid multi-mutation.</p> <p>This checks that if a multi contains specific mutations, they should not be covered by general mutations which this multi includes.</p> <p>Parameters:</p> Name Type Description Default <code>mutation</code> <code>str</code> <p>Multi-mutation</p> required Source code in <code>piezo/grammar_GARC1.py</code> <pre><code>def validate_multi(mutation: str) -&gt; None:\n    \"\"\"Validate that we have a valid multi-mutation.\n\n    This checks that if a multi contains specific mutations, they should not be covered\n    by general mutations which this multi includes.\n\n    Args:\n        mutation (str): Multi-mutation\n    \"\"\"\n    # If we have a specific rule, combined with a general rule which covers it,\n    #   that should be reduced, so it's invalid.\n    # If we were to allow defaults which cover specifics, the multi matching would break\n    #\n    # Easiest way to do this is to take general rules and construct a catalogue\n    #   from them, then, pass in all specific rules, and if we get a match on any of\n    #   them, they are covered by a general rule\n    rule_mutations = mutation.split(\"&amp;\")\n    dummy_cat = {\n        \"EVIDENCE\": [\n            ujson.dumps({\"Rule hit\": idx}) for (idx, _) in enumerate(rule_mutations)\n        ],\n        \"MUTATION\": rule_mutations,\n        \"DRUG\": [\"na\" for _ in rule_mutations],\n        \"PREDICTION\": [\"R\" for _ in rule_mutations],\n    }\n    r = pandas.DataFrame(dummy_cat)\n    r[\n        [\"GENE\", \"MUTATION\", \"POSITION\", \"MUTATION_AFFECTS\", \"MUTATION_TYPE\", \"MINOR\"]\n    ] = r.apply(split_mutation, axis=1)\n\n    generals = r[(r[\"POSITION\"] == \"*\") | (r[\"MUTATION\"].str.contains(r\"\\?\"))]\n    specifics = r[(r[\"POSITION\"] != \"*\") &amp; (~r[\"MUTATION\"].str.contains(r\"\\?\"))]\n    # As this is a named **tuple**, it is immutable so create a new one\n    cat = Catalogue(\n        \"NC_000962.3\",\n        \"generic\",\n        \"1.0\",\n        \"GARC1\",\n        \"R\",  # Obviously not R but RFUS are needed here\n        [\"na\"],\n        generals[\"GENE\"].tolist(),\n        {\"na\": generals[\"GENE\"].tolist()},\n        {gene: [\"na\"] for gene in generals[\"GENE\"].tolist()},\n        len(generals),\n        generals,\n    )\n    for _, row in specifics.iterrows():\n        try:\n            pred = predict_GARC1(cat, \"@\".join(row[[\"GENE\", \"MUTATION\"]]))\n            if pred != \"S\":\n                raise ValueError(\n                    \"Badly formed mutation: \"\n                    + mutation\n                    + \" contains generic rules which cover specific rules!\"\n                )\n        except ValueError as e:\n            if \"Badly formed mutation: \" in str(e):\n                # If we're catching the exception we just threw, re-throw it\n                raise e\n            continue\n</code></pre>"}]}